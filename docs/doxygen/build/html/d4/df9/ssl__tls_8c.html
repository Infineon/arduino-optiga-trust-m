<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OPTIGA Trust M: ssl_tls.c File Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../ifx_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OPTIGA Trust M
   &#160;<span id="projectnumber">1.1.0</span>
   </div>
   <div id="projectbrief">C++ library for Optiga Trust M Chip Security Controller</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('d4/df9/ssl__tls_8c.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">ssl_tls.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4b188ac79655c2940f088fa8ea5eb47a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a4b188ac79655c2940f088fa8ea5eb47a">mbedtls_ssl_derive_keys</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl)</td></tr>
<tr class="separator:a4b188ac79655c2940f088fa8ea5eb47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd72b8a9403870505bba5829fa1a00b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#aebd72b8a9403870505bba5829fa1a00b">ssl_calc_verify_ssl</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl, unsigned char hash[36])</td></tr>
<tr class="separator:aebd72b8a9403870505bba5829fa1a00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5529a8422a9cd4ed7a3503e6e11c7042"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a5529a8422a9cd4ed7a3503e6e11c7042">ssl_calc_verify_tls</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl, unsigned char hash[36])</td></tr>
<tr class="separator:a5529a8422a9cd4ed7a3503e6e11c7042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d29022ea4cc8da03957fcda703e2d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a95d29022ea4cc8da03957fcda703e2d8">ssl_calc_verify_tls_sha256</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl, unsigned char hash[32])</td></tr>
<tr class="separator:a95d29022ea4cc8da03957fcda703e2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23aee11f334c5dc7e18ddc9705f89a6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a23aee11f334c5dc7e18ddc9705f89a6e">ssl_calc_verify_tls_sha384</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl, unsigned char hash[48])</td></tr>
<tr class="separator:a23aee11f334c5dc7e18ddc9705f89a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9518f4ada60690c9fb45a8576e8a9925"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a9518f4ada60690c9fb45a8576e8a9925">mbedtls_ssl_psk_derive_premaster</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl, <a class="el" href="../../df/d01/ssl__ciphersuites_8h.html#ae04606bda9a15cfd8bd51c2f6fd52a3a">mbedtls_key_exchange_type_t</a> key_ex)</td></tr>
<tr class="separator:a9518f4ada60690c9fb45a8576e8a9925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28834d530cc3814037af2e998300535f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a28834d530cc3814037af2e998300535f">mbedtls_ssl_fetch_input</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl, size_t nb_want)</td></tr>
<tr class="separator:a28834d530cc3814037af2e998300535f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae06b33ccfcd45627a80fd851e608ebff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#ae06b33ccfcd45627a80fd851e608ebff">mbedtls_ssl_flush_output</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl)</td></tr>
<tr class="separator:ae06b33ccfcd45627a80fd851e608ebff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2247e73d226008173334d8f74e91c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#acf2247e73d226008173334d8f74e91c7">mbedtls_ssl_resend</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl)</td></tr>
<tr class="separator:acf2247e73d226008173334d8f74e91c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a68cbd0dd94c8e85b1f58a0a358138"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a10a68cbd0dd94c8e85b1f58a0a358138">mbedtls_ssl_flight_transmit</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl)</td></tr>
<tr class="separator:a10a68cbd0dd94c8e85b1f58a0a358138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81065530f05242ebf432dd842037bf5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#af81065530f05242ebf432dd842037bf5">mbedtls_ssl_recv_flight_completed</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl)</td></tr>
<tr class="separator:af81065530f05242ebf432dd842037bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fcf940a335d71a7896591da175cca50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a0fcf940a335d71a7896591da175cca50">mbedtls_ssl_send_flight_completed</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl)</td></tr>
<tr class="separator:a0fcf940a335d71a7896591da175cca50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe627c62fdc4ba7225f59b7f1596a95"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a8fe627c62fdc4ba7225f59b7f1596a95">mbedtls_ssl_write_handshake_msg</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl)</td></tr>
<tr class="separator:a8fe627c62fdc4ba7225f59b7f1596a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56dba26b0d35cd109798849dd8d9e304"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a56dba26b0d35cd109798849dd8d9e304">mbedtls_ssl_write_record</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl, uint8_t force_flush)</td></tr>
<tr class="separator:a56dba26b0d35cd109798849dd8d9e304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356520cef18fad75652d4d115d310c76"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a356520cef18fad75652d4d115d310c76">mbedtls_ssl_prepare_handshake_record</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl)</td></tr>
<tr class="separator:a356520cef18fad75652d4d115d310c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addad18433e4cb4392a1f0cdec16103de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#addad18433e4cb4392a1f0cdec16103de">mbedtls_ssl_update_handshake_status</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl)</td></tr>
<tr class="separator:addad18433e4cb4392a1f0cdec16103de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a54cf83f503ba4bb7bc0a0a0a4ae259"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a1a54cf83f503ba4bb7bc0a0a0a4ae259">mbedtls_ssl_dtls_replay_check</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl)</td></tr>
<tr class="separator:a1a54cf83f503ba4bb7bc0a0a0a4ae259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f44a6f167e74e6e5d71a6ee740a3b57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a3f44a6f167e74e6e5d71a6ee740a3b57">mbedtls_ssl_dtls_replay_update</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl)</td></tr>
<tr class="separator:a3f44a6f167e74e6e5d71a6ee740a3b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace66a0d800c2e5cddfcd8d62aa675f7c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#ace66a0d800c2e5cddfcd8d62aa675f7c">mbedtls_ssl_read_record</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl, unsigned update_hs_digest)</td></tr>
<tr class="memdesc:ace66a0d800c2e5cddfcd8d62aa675f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update record layer.  <a href="../../d4/df9/ssl__tls_8c.html#ace66a0d800c2e5cddfcd8d62aa675f7c">More...</a><br /></td></tr>
<tr class="separator:ace66a0d800c2e5cddfcd8d62aa675f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74140ac05c1ae66adbd4a8cb62451ee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#ac74140ac05c1ae66adbd4a8cb62451ee">mbedtls_ssl_handle_message_type</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl)</td></tr>
<tr class="separator:ac74140ac05c1ae66adbd4a8cb62451ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8abadab965dc3e658c2771b30244b4c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#ac8abadab965dc3e658c2771b30244b4c">mbedtls_ssl_send_fatal_handshake_failure</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl)</td></tr>
<tr class="separator:ac8abadab965dc3e658c2771b30244b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431e67252731a34bd9b5f2c9222f4c43"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a431e67252731a34bd9b5f2c9222f4c43">mbedtls_ssl_send_alert_message</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl, unsigned char level, unsigned char message)</td></tr>
<tr class="memdesc:a431e67252731a34bd9b5f2c9222f4c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send an alert message.  <a href="../../d4/df9/ssl__tls_8c.html#a431e67252731a34bd9b5f2c9222f4c43">More...</a><br /></td></tr>
<tr class="separator:a431e67252731a34bd9b5f2c9222f4c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d10db1fb3bd2b514124fe411b4e030"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#ad5d10db1fb3bd2b514124fe411b4e030">mbedtls_ssl_write_certificate</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl)</td></tr>
<tr class="separator:ad5d10db1fb3bd2b514124fe411b4e030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84dc812afc4e0b8c71e4df27abed114a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a84dc812afc4e0b8c71e4df27abed114a">mbedtls_ssl_parse_certificate</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl)</td></tr>
<tr class="separator:a84dc812afc4e0b8c71e4df27abed114a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae2eeddd9d9b7a974cfa89add112288"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a0ae2eeddd9d9b7a974cfa89add112288">mbedtls_ssl_write_change_cipher_spec</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl)</td></tr>
<tr class="separator:a0ae2eeddd9d9b7a974cfa89add112288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99ea2532d111be262e1d528dbd67a3b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#ab99ea2532d111be262e1d528dbd67a3b">mbedtls_ssl_parse_change_cipher_spec</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl)</td></tr>
<tr class="separator:ab99ea2532d111be262e1d528dbd67a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0271511696869c311621c09d3373e47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#ab0271511696869c311621c09d3373e47">mbedtls_ssl_optimize_checksum</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl, const <a class="el" href="../../dd/d7a/structmbedtls__ssl__ciphersuite__t.html">mbedtls_ssl_ciphersuite_t</a> *ciphersuite_info)</td></tr>
<tr class="separator:ab0271511696869c311621c09d3373e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5965ab35a26a158ea971c8f87a7f1db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#ad5965ab35a26a158ea971c8f87a7f1db">mbedtls_ssl_reset_checksum</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl)</td></tr>
<tr class="separator:ad5965ab35a26a158ea971c8f87a7f1db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a499c99645f5a59656b3b0724a586b31d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a499c99645f5a59656b3b0724a586b31d">mbedtls_ssl_handshake_wrapup</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl)</td></tr>
<tr class="separator:a499c99645f5a59656b3b0724a586b31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ec0d34dc6670ef0355c88489fd8e59"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a42ec0d34dc6670ef0355c88489fd8e59">mbedtls_ssl_write_finished</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl)</td></tr>
<tr class="separator:a42ec0d34dc6670ef0355c88489fd8e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081a893301f22c2db38c15ef2697ac48"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a081a893301f22c2db38c15ef2697ac48">mbedtls_ssl_parse_finished</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl)</td></tr>
<tr class="separator:a081a893301f22c2db38c15ef2697ac48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7980469655c1cdb8fd7e966bffe1fd02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a7980469655c1cdb8fd7e966bffe1fd02">mbedtls_ssl_session_init</a> (<a class="el" href="../../da/def/structmbedtls__ssl__session.html">mbedtls_ssl_session</a> *session)</td></tr>
<tr class="memdesc:a7980469655c1cdb8fd7e966bffe1fd02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize SSL session structure.  <a href="../../d4/df9/ssl__tls_8c.html#a7980469655c1cdb8fd7e966bffe1fd02">More...</a><br /></td></tr>
<tr class="separator:a7980469655c1cdb8fd7e966bffe1fd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8560dea66d7830a11874188727ec4c45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a8560dea66d7830a11874188727ec4c45">mbedtls_ssl_init</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl)</td></tr>
<tr class="memdesc:a8560dea66d7830a11874188727ec4c45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an SSL context Just makes the context ready for <a class="el" href="../../df/d6d/ssl_8h.html#af79cb539a0ee6ac20cf9c574f4c3b343" title="Set up an SSL context for use.">mbedtls_ssl_setup()</a> or <a class="el" href="../../df/d6d/ssl_8h.html#a2dc104a181bcd11eafbbf7e6923978bc" title="Free referenced items in an SSL context and clear memory.">mbedtls_ssl_free()</a>  <a href="../../d4/df9/ssl__tls_8c.html#a8560dea66d7830a11874188727ec4c45">More...</a><br /></td></tr>
<tr class="separator:a8560dea66d7830a11874188727ec4c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af79cb539a0ee6ac20cf9c574f4c3b343"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#af79cb539a0ee6ac20cf9c574f4c3b343">mbedtls_ssl_setup</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl, const <a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf)</td></tr>
<tr class="memdesc:af79cb539a0ee6ac20cf9c574f4c3b343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up an SSL context for use.  <a href="../../d4/df9/ssl__tls_8c.html#af79cb539a0ee6ac20cf9c574f4c3b343">More...</a><br /></td></tr>
<tr class="separator:af79cb539a0ee6ac20cf9c574f4c3b343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21432367cbce428f10dcb62d9456fa7e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a21432367cbce428f10dcb62d9456fa7e">mbedtls_ssl_session_reset</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl)</td></tr>
<tr class="memdesc:a21432367cbce428f10dcb62d9456fa7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset an already initialized SSL context for re-use while retaining application-set variables, function pointers and data.  <a href="../../d4/df9/ssl__tls_8c.html#a21432367cbce428f10dcb62d9456fa7e">More...</a><br /></td></tr>
<tr class="separator:a21432367cbce428f10dcb62d9456fa7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a763e35d55c18e6792a3b756d825684"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a3a763e35d55c18e6792a3b756d825684">mbedtls_ssl_conf_endpoint</a> (<a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf, int endpoint)</td></tr>
<tr class="memdesc:a3a763e35d55c18e6792a3b756d825684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current endpoint type.  <a href="../../d4/df9/ssl__tls_8c.html#a3a763e35d55c18e6792a3b756d825684">More...</a><br /></td></tr>
<tr class="separator:a3a763e35d55c18e6792a3b756d825684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb03afe9b2ca0f144a1c307100dc0ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a2eb03afe9b2ca0f144a1c307100dc0ca">mbedtls_ssl_conf_transport</a> (<a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf, int transport)</td></tr>
<tr class="memdesc:a2eb03afe9b2ca0f144a1c307100dc0ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the transport type (TLS or DTLS). Default: TLS.  <a href="../../d4/df9/ssl__tls_8c.html#a2eb03afe9b2ca0f144a1c307100dc0ca">More...</a><br /></td></tr>
<tr class="separator:a2eb03afe9b2ca0f144a1c307100dc0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d919254eafef2ae642fb692c5e560a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a46d919254eafef2ae642fb692c5e560a">mbedtls_ssl_conf_dtls_anti_replay</a> (<a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf, char mode)</td></tr>
<tr class="memdesc:a46d919254eafef2ae642fb692c5e560a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable anti-replay protection for DTLS. (DTLS only, no effect on TLS.) Default: enabled.  <a href="../../d4/df9/ssl__tls_8c.html#a46d919254eafef2ae642fb692c5e560a">More...</a><br /></td></tr>
<tr class="separator:a46d919254eafef2ae642fb692c5e560a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9baa37a4b839319d00d8b43c8d266719"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a9baa37a4b839319d00d8b43c8d266719">mbedtls_ssl_conf_dtls_badmac_limit</a> (<a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf, unsigned limit)</td></tr>
<tr class="memdesc:a9baa37a4b839319d00d8b43c8d266719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a limit on the number of records with a bad MAC before terminating the connection. (DTLS only, no effect on TLS.) Default: 0 (disabled).  <a href="../../d4/df9/ssl__tls_8c.html#a9baa37a4b839319d00d8b43c8d266719">More...</a><br /></td></tr>
<tr class="separator:a9baa37a4b839319d00d8b43c8d266719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84238750762b8cf8a6ca25d08efcc1ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a84238750762b8cf8a6ca25d08efcc1ab">mbedtls_ssl_set_datagram_packing</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl, unsigned allow_packing)</td></tr>
<tr class="memdesc:a84238750762b8cf8a6ca25d08efcc1ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow or disallow packing of multiple handshake records within a single datagram.  <a href="../../d4/df9/ssl__tls_8c.html#a84238750762b8cf8a6ca25d08efcc1ab">More...</a><br /></td></tr>
<tr class="separator:a84238750762b8cf8a6ca25d08efcc1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6625bc4e7ffd535900ef53259cc21651"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a6625bc4e7ffd535900ef53259cc21651">mbedtls_ssl_conf_handshake_timeout</a> (<a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf, uint32_t min, uint32_t max)</td></tr>
<tr class="memdesc:a6625bc4e7ffd535900ef53259cc21651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set retransmit timeout values for the DTLS handshake. (DTLS only, no effect on TLS.)  <a href="../../d4/df9/ssl__tls_8c.html#a6625bc4e7ffd535900ef53259cc21651">More...</a><br /></td></tr>
<tr class="separator:a6625bc4e7ffd535900ef53259cc21651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5695285c9dbfefec295012b566290f37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a5695285c9dbfefec295012b566290f37">mbedtls_ssl_conf_authmode</a> (<a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf, int authmode)</td></tr>
<tr class="memdesc:a5695285c9dbfefec295012b566290f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the certificate verification mode Default: NONE on server, REQUIRED on client.  <a href="../../d4/df9/ssl__tls_8c.html#a5695285c9dbfefec295012b566290f37">More...</a><br /></td></tr>
<tr class="separator:a5695285c9dbfefec295012b566290f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc2b6b55d7ccaf38d84a4fbf1655f426"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#afc2b6b55d7ccaf38d84a4fbf1655f426">mbedtls_ssl_conf_verify</a> (<a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf, int(*f_vrfy)(void *, <a class="el" href="../../d6/daa/structmbedtls__x509__crt.html">mbedtls_x509_crt</a> *, int, uint32_t *), void *p_vrfy)</td></tr>
<tr class="memdesc:afc2b6b55d7ccaf38d84a4fbf1655f426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the verification callback (Optional).  <a href="../../d4/df9/ssl__tls_8c.html#afc2b6b55d7ccaf38d84a4fbf1655f426">More...</a><br /></td></tr>
<tr class="separator:afc2b6b55d7ccaf38d84a4fbf1655f426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a469cd1c64bbba4be22347bf8874a017e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a469cd1c64bbba4be22347bf8874a017e">mbedtls_ssl_conf_rng</a> (<a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf, int(*f_rng)(void *, unsigned char *, size_t), void *p_rng)</td></tr>
<tr class="memdesc:a469cd1c64bbba4be22347bf8874a017e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the random number generator callback.  <a href="../../d4/df9/ssl__tls_8c.html#a469cd1c64bbba4be22347bf8874a017e">More...</a><br /></td></tr>
<tr class="separator:a469cd1c64bbba4be22347bf8874a017e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15dcbe7c7fe2a5c118e7c486c07c921"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#ab15dcbe7c7fe2a5c118e7c486c07c921">mbedtls_ssl_conf_dbg</a> (<a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf, void(*f_dbg)(void *, int, const char *, int, const char *), void *p_dbg)</td></tr>
<tr class="memdesc:ab15dcbe7c7fe2a5c118e7c486c07c921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the debug callback.  <a href="../../d4/df9/ssl__tls_8c.html#ab15dcbe7c7fe2a5c118e7c486c07c921">More...</a><br /></td></tr>
<tr class="separator:ab15dcbe7c7fe2a5c118e7c486c07c921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7442420aef7f1a76fa8c5336362f9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a8b7442420aef7f1a76fa8c5336362f9e">mbedtls_ssl_set_bio</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl, void *p_bio, <a class="el" href="../../df/d6d/ssl_8h.html#a38e2b400d361f42f85833cdc30b3916e">mbedtls_ssl_send_t</a> *f_send, <a class="el" href="../../df/d6d/ssl_8h.html#ac06b19b96b643090c55f19b6c28b10c4">mbedtls_ssl_recv_t</a> *f_recv, <a class="el" href="../../df/d6d/ssl_8h.html#a6d615ca95c8a67d7c5f9d7d256dc09e6">mbedtls_ssl_recv_timeout_t</a> *f_recv_timeout)</td></tr>
<tr class="memdesc:a8b7442420aef7f1a76fa8c5336362f9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the underlying BIO callbacks for write, read and read-with-timeout.  <a href="../../d4/df9/ssl__tls_8c.html#a8b7442420aef7f1a76fa8c5336362f9e">More...</a><br /></td></tr>
<tr class="separator:a8b7442420aef7f1a76fa8c5336362f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ea71eb9f064d28fb5c393acc1e6975"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a14ea71eb9f064d28fb5c393acc1e6975">mbedtls_ssl_set_mtu</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl, uint16_t mtu)</td></tr>
<tr class="memdesc:a14ea71eb9f064d28fb5c393acc1e6975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Maximum Tranport Unit (MTU). Special value: 0 means unset (no limit). This represents the maximum size of a datagram payload handled by the transport layer (usually UDP) as determined by the network link and stack. In practice, this controls the maximum size datagram the DTLS layer will pass to the <code>f_send()</code> callback set using <code><a class="el" href="../../df/d6d/ssl_8h.html#a8b7442420aef7f1a76fa8c5336362f9e" title="Set the underlying BIO callbacks for write, read and read-with-timeout.">mbedtls_ssl_set_bio()</a></code>.  <a href="../../d4/df9/ssl__tls_8c.html#a14ea71eb9f064d28fb5c393acc1e6975">More...</a><br /></td></tr>
<tr class="separator:a14ea71eb9f064d28fb5c393acc1e6975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d925033b3a46a48b3f8acc1d743af90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a0d925033b3a46a48b3f8acc1d743af90">mbedtls_ssl_conf_read_timeout</a> (<a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf, uint32_t timeout)</td></tr>
<tr class="memdesc:a0d925033b3a46a48b3f8acc1d743af90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the timeout period for <a class="el" href="../../df/d6d/ssl_8h.html#aa2c29eeb1deaf5ad9f01a7515006ede5" title="Read at most &#39;len&#39; application data bytes.">mbedtls_ssl_read()</a> (Default: no timeout.)  <a href="../../d4/df9/ssl__tls_8c.html#a0d925033b3a46a48b3f8acc1d743af90">More...</a><br /></td></tr>
<tr class="separator:a0d925033b3a46a48b3f8acc1d743af90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335ee78886daf7f8fb369fa925b3cca8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a335ee78886daf7f8fb369fa925b3cca8">mbedtls_ssl_set_timer_cb</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl, void *p_timer, <a class="el" href="../../df/d6d/ssl_8h.html#a61c5d9ed63c50ee809eec98820d3f36c">mbedtls_ssl_set_timer_t</a> *f_set_timer, <a class="el" href="../../df/d6d/ssl_8h.html#adea005600b532d788c05e9d01b42895b">mbedtls_ssl_get_timer_t</a> *f_get_timer)</td></tr>
<tr class="memdesc:a335ee78886daf7f8fb369fa925b3cca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the timer callbacks (Mandatory for DTLS.)  <a href="../../d4/df9/ssl__tls_8c.html#a335ee78886daf7f8fb369fa925b3cca8">More...</a><br /></td></tr>
<tr class="separator:a335ee78886daf7f8fb369fa925b3cca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a69464288d80b3904bc7540bd52aab0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a9a69464288d80b3904bc7540bd52aab0">mbedtls_ssl_conf_session_cache</a> (<a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf, void *p_cache, int(*f_get_cache)(void *, <a class="el" href="../../da/def/structmbedtls__ssl__session.html">mbedtls_ssl_session</a> *), int(*f_set_cache)(void *, const <a class="el" href="../../da/def/structmbedtls__ssl__session.html">mbedtls_ssl_session</a> *))</td></tr>
<tr class="memdesc:a9a69464288d80b3904bc7540bd52aab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the session cache callbacks (server-side only) If not set, no session resuming is done (except if session tickets are enabled too).  <a href="../../d4/df9/ssl__tls_8c.html#a9a69464288d80b3904bc7540bd52aab0">More...</a><br /></td></tr>
<tr class="separator:a9a69464288d80b3904bc7540bd52aab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91be5c606b9f7c1e44b3e507a4fe7b66"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a91be5c606b9f7c1e44b3e507a4fe7b66">mbedtls_ssl_set_session</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl, const <a class="el" href="../../da/def/structmbedtls__ssl__session.html">mbedtls_ssl_session</a> *session)</td></tr>
<tr class="memdesc:a91be5c606b9f7c1e44b3e507a4fe7b66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request resumption of session (client-side only) Session data is copied from presented session structure.  <a href="../../d4/df9/ssl__tls_8c.html#a91be5c606b9f7c1e44b3e507a4fe7b66">More...</a><br /></td></tr>
<tr class="separator:a91be5c606b9f7c1e44b3e507a4fe7b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e4df37cadda8f743ed45501a51fec1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#ac8e4df37cadda8f743ed45501a51fec1">mbedtls_ssl_conf_ciphersuites</a> (<a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf, const int *ciphersuites)</td></tr>
<tr class="memdesc:ac8e4df37cadda8f743ed45501a51fec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the list of allowed ciphersuites and the preference order. First in the list has the highest preference. (Overrides all version-specific lists)  <a href="../../d4/df9/ssl__tls_8c.html#ac8e4df37cadda8f743ed45501a51fec1">More...</a><br /></td></tr>
<tr class="separator:ac8e4df37cadda8f743ed45501a51fec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa597f5461c48ee6014397c926916e6ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#aa597f5461c48ee6014397c926916e6ae">mbedtls_ssl_conf_ciphersuites_for_version</a> (<a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf, const int *ciphersuites, int major, int minor)</td></tr>
<tr class="memdesc:aa597f5461c48ee6014397c926916e6ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the list of allowed ciphersuites and the preference order for a specific version of the protocol. (Only useful on the server side)  <a href="../../d4/df9/ssl__tls_8c.html#aa597f5461c48ee6014397c926916e6ae">More...</a><br /></td></tr>
<tr class="separator:aa597f5461c48ee6014397c926916e6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76dc3c312ffd51f6d0ca127b322307bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a76dc3c312ffd51f6d0ca127b322307bb">mbedtls_ssl_conf_cert_profile</a> (<a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf, const <a class="el" href="../../d8/d1b/structmbedtls__x509__crt__profile.html">mbedtls_x509_crt_profile</a> *profile)</td></tr>
<tr class="memdesc:a76dc3c312ffd51f6d0ca127b322307bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the X.509 security profile used for verification.  <a href="../../d4/df9/ssl__tls_8c.html#a76dc3c312ffd51f6d0ca127b322307bb">More...</a><br /></td></tr>
<tr class="separator:a76dc3c312ffd51f6d0ca127b322307bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e54e9ace21beb608bae36ddb81a4fb0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a4e54e9ace21beb608bae36ddb81a4fb0">mbedtls_ssl_conf_own_cert</a> (<a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf, <a class="el" href="../../d6/daa/structmbedtls__x509__crt.html">mbedtls_x509_crt</a> *own_cert, <a class="el" href="../../d0/d1b/structmbedtls__pk__context.html">mbedtls_pk_context</a> *pk_key)</td></tr>
<tr class="memdesc:a4e54e9ace21beb608bae36ddb81a4fb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set own certificate chain and private key.  <a href="../../d4/df9/ssl__tls_8c.html#a4e54e9ace21beb608bae36ddb81a4fb0">More...</a><br /></td></tr>
<tr class="separator:a4e54e9ace21beb608bae36ddb81a4fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c3bb6b682ba361d13de1c0a1eb69fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a85c3bb6b682ba361d13de1c0a1eb69fb">mbedtls_ssl_conf_ca_chain</a> (<a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf, <a class="el" href="../../d6/daa/structmbedtls__x509__crt.html">mbedtls_x509_crt</a> *ca_chain, <a class="el" href="../../d1/d39/structmbedtls__x509__crl.html">mbedtls_x509_crl</a> *ca_crl)</td></tr>
<tr class="memdesc:a85c3bb6b682ba361d13de1c0a1eb69fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the data required to verify peer certificate.  <a href="../../d4/df9/ssl__tls_8c.html#a85c3bb6b682ba361d13de1c0a1eb69fb">More...</a><br /></td></tr>
<tr class="separator:a85c3bb6b682ba361d13de1c0a1eb69fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0353666974b1cd19dafb2c2b165d2f2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#aa0353666974b1cd19dafb2c2b165d2f2">mbedtls_ssl_set_hs_own_cert</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl, <a class="el" href="../../d6/daa/structmbedtls__x509__crt.html">mbedtls_x509_crt</a> *own_cert, <a class="el" href="../../d0/d1b/structmbedtls__pk__context.html">mbedtls_pk_context</a> *pk_key)</td></tr>
<tr class="memdesc:aa0353666974b1cd19dafb2c2b165d2f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set own certificate and key for the current handshake.  <a href="../../d4/df9/ssl__tls_8c.html#aa0353666974b1cd19dafb2c2b165d2f2">More...</a><br /></td></tr>
<tr class="separator:aa0353666974b1cd19dafb2c2b165d2f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a781dcdc16bd649ea0346a598e9656"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a33a781dcdc16bd649ea0346a598e9656">mbedtls_ssl_set_hs_ca_chain</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl, <a class="el" href="../../d6/daa/structmbedtls__x509__crt.html">mbedtls_x509_crt</a> *ca_chain, <a class="el" href="../../d1/d39/structmbedtls__x509__crl.html">mbedtls_x509_crl</a> *ca_crl)</td></tr>
<tr class="memdesc:a33a781dcdc16bd649ea0346a598e9656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the data required to verify peer certificate for the current handshake.  <a href="../../d4/df9/ssl__tls_8c.html#a33a781dcdc16bd649ea0346a598e9656">More...</a><br /></td></tr>
<tr class="separator:a33a781dcdc16bd649ea0346a598e9656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8366b49e25054078b5be139c0ce560d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a8366b49e25054078b5be139c0ce560d7">mbedtls_ssl_set_hs_authmode</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl, int authmode)</td></tr>
<tr class="memdesc:a8366b49e25054078b5be139c0ce560d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set authmode for the current handshake.  <a href="../../d4/df9/ssl__tls_8c.html#a8366b49e25054078b5be139c0ce560d7">More...</a><br /></td></tr>
<tr class="separator:a8366b49e25054078b5be139c0ce560d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ec09a4ebfcc3676807a0c83985bf15"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a36ec09a4ebfcc3676807a0c83985bf15">mbedtls_ssl_set_hs_ecjpake_password</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl, const unsigned char *pw, size_t pw_len)</td></tr>
<tr class="memdesc:a36ec09a4ebfcc3676807a0c83985bf15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the EC J-PAKE password for current handshake.  <a href="../../d4/df9/ssl__tls_8c.html#a36ec09a4ebfcc3676807a0c83985bf15">More...</a><br /></td></tr>
<tr class="separator:a36ec09a4ebfcc3676807a0c83985bf15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e185199e3ff613bdd1c8231a19e24fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a1e185199e3ff613bdd1c8231a19e24fc">mbedtls_ssl_conf_psk</a> (<a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf, const unsigned char *psk, size_t psk_len, const unsigned char *psk_identity, size_t psk_identity_len)</td></tr>
<tr class="memdesc:a1e185199e3ff613bdd1c8231a19e24fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Pre Shared Key (PSK) and the expected identity name.  <a href="../../d4/df9/ssl__tls_8c.html#a1e185199e3ff613bdd1c8231a19e24fc">More...</a><br /></td></tr>
<tr class="separator:a1e185199e3ff613bdd1c8231a19e24fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f8bb06a3ec75f6fec4ccc2c1aad151"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a50f8bb06a3ec75f6fec4ccc2c1aad151">mbedtls_ssl_set_hs_psk</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl, const unsigned char *psk, size_t psk_len)</td></tr>
<tr class="memdesc:a50f8bb06a3ec75f6fec4ccc2c1aad151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Pre Shared Key (PSK) for the current handshake.  <a href="../../d4/df9/ssl__tls_8c.html#a50f8bb06a3ec75f6fec4ccc2c1aad151">More...</a><br /></td></tr>
<tr class="separator:a50f8bb06a3ec75f6fec4ccc2c1aad151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b804626a236e493316c58b048ab5937"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a1b804626a236e493316c58b048ab5937">mbedtls_ssl_conf_psk_cb</a> (<a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf, int(*f_psk)(void *, <a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *, const unsigned char *, size_t), void *p_psk)</td></tr>
<tr class="memdesc:a1b804626a236e493316c58b048ab5937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the PSK callback (server-side only).  <a href="../../d4/df9/ssl__tls_8c.html#a1b804626a236e493316c58b048ab5937">More...</a><br /></td></tr>
<tr class="separator:a1b804626a236e493316c58b048ab5937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62445aeddae0780ea2247c455a3d965d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a62445aeddae0780ea2247c455a3d965d">mbedtls_ssl_conf_dh_param</a> (<a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf, const char *dhm_P, const char *dhm_G)</td></tr>
<tr class="memdesc:a62445aeddae0780ea2247c455a3d965d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Diffie-Hellman public P and G values, read as hexadecimal strings (server-side only) (Default values: MBEDTLS_DHM_RFC3526_MODP_2048_[PG])  <a href="../../d4/df9/ssl__tls_8c.html#a62445aeddae0780ea2247c455a3d965d">More...</a><br /></td></tr>
<tr class="separator:a62445aeddae0780ea2247c455a3d965d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457078c76cf96c9696fd226c8efe0674"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a457078c76cf96c9696fd226c8efe0674">mbedtls_ssl_conf_dh_param_bin</a> (<a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf, const unsigned char *dhm_P, size_t P_len, const unsigned char *dhm_G, size_t G_len)</td></tr>
<tr class="memdesc:a457078c76cf96c9696fd226c8efe0674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Diffie-Hellman public P and G values from big-endian binary presentations. (Default values: MBEDTLS_DHM_RFC3526_MODP_2048_[PG]_BIN)  <a href="../../d4/df9/ssl__tls_8c.html#a457078c76cf96c9696fd226c8efe0674">More...</a><br /></td></tr>
<tr class="separator:a457078c76cf96c9696fd226c8efe0674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6d67681da3a0d5cb259137af176d56"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#aec6d67681da3a0d5cb259137af176d56">mbedtls_ssl_conf_dh_param_ctx</a> (<a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf, <a class="el" href="../../dd/d97/structmbedtls__dhm__context.html">mbedtls_dhm_context</a> *dhm_ctx)</td></tr>
<tr class="memdesc:aec6d67681da3a0d5cb259137af176d56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Diffie-Hellman public P and G values, read from existing context (server-side only)  <a href="../../d4/df9/ssl__tls_8c.html#aec6d67681da3a0d5cb259137af176d56">More...</a><br /></td></tr>
<tr class="separator:aec6d67681da3a0d5cb259137af176d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd56f07a798d344dba5bcf33376edfd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a9dd56f07a798d344dba5bcf33376edfd">mbedtls_ssl_conf_dhm_min_bitlen</a> (<a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf, unsigned int bitlen)</td></tr>
<tr class="memdesc:a9dd56f07a798d344dba5bcf33376edfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the minimum length for Diffie-Hellman parameters. (Client-side only.) (Default: 1024 bits.)  <a href="../../d4/df9/ssl__tls_8c.html#a9dd56f07a798d344dba5bcf33376edfd">More...</a><br /></td></tr>
<tr class="separator:a9dd56f07a798d344dba5bcf33376edfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73725fed867e0fd29396c7c6565a76e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a73725fed867e0fd29396c7c6565a76e6">mbedtls_ssl_conf_sig_hashes</a> (<a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf, const int *hashes)</td></tr>
<tr class="memdesc:a73725fed867e0fd29396c7c6565a76e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the allowed hashes for signatures during the handshake. (Default: all available hashes except MD5.)  <a href="../../d4/df9/ssl__tls_8c.html#a73725fed867e0fd29396c7c6565a76e6">More...</a><br /></td></tr>
<tr class="separator:a73725fed867e0fd29396c7c6565a76e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60aaca8d54408d349d110280f06653b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a60aaca8d54408d349d110280f06653b9">mbedtls_ssl_conf_curves</a> (<a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf, const <a class="el" href="../../de/df7/ecp_8h.html#af79e530ea8f8416480f805baa20b1a2d">mbedtls_ecp_group_id</a> *curve_list)</td></tr>
<tr class="memdesc:a60aaca8d54408d349d110280f06653b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the allowed curves in order of preference. (Default: all defined curves.)  <a href="../../d4/df9/ssl__tls_8c.html#a60aaca8d54408d349d110280f06653b9">More...</a><br /></td></tr>
<tr class="separator:a60aaca8d54408d349d110280f06653b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa659024cf89e20d6d2248c0626db7ef2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#aa659024cf89e20d6d2248c0626db7ef2">mbedtls_ssl_set_hostname</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl, const char *hostname)</td></tr>
<tr class="memdesc:aa659024cf89e20d6d2248c0626db7ef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set or reset the hostname to check against the received server certificate. It sets the ServerName TLS extension, too, if that extension is enabled. (client-side only)  <a href="../../d4/df9/ssl__tls_8c.html#aa659024cf89e20d6d2248c0626db7ef2">More...</a><br /></td></tr>
<tr class="separator:aa659024cf89e20d6d2248c0626db7ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ee2c1e3f232444df5ba3952d7ded33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a38ee2c1e3f232444df5ba3952d7ded33">mbedtls_ssl_conf_sni</a> (<a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf, int(*f_sni)(void *, <a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *, const unsigned char *, size_t), void *p_sni)</td></tr>
<tr class="memdesc:a38ee2c1e3f232444df5ba3952d7ded33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set server side ServerName TLS extension callback (optional, server-side only).  <a href="../../d4/df9/ssl__tls_8c.html#a38ee2c1e3f232444df5ba3952d7ded33">More...</a><br /></td></tr>
<tr class="separator:a38ee2c1e3f232444df5ba3952d7ded33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21135dddd89b2ef273c13e140097f5a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#ae21135dddd89b2ef273c13e140097f5a">mbedtls_ssl_conf_alpn_protocols</a> (<a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf, const char **protos)</td></tr>
<tr class="memdesc:ae21135dddd89b2ef273c13e140097f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the supported Application Layer Protocols.  <a href="../../d4/df9/ssl__tls_8c.html#ae21135dddd89b2ef273c13e140097f5a">More...</a><br /></td></tr>
<tr class="separator:ae21135dddd89b2ef273c13e140097f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ab606db1a9307b4aacccdcd1d1a6ef"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#ad1ab606db1a9307b4aacccdcd1d1a6ef">mbedtls_ssl_get_alpn_protocol</a> (const <a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl)</td></tr>
<tr class="memdesc:ad1ab606db1a9307b4aacccdcd1d1a6ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the negotiated Application Layer Protocol. This function should be called after the handshake is completed.  <a href="../../d4/df9/ssl__tls_8c.html#ad1ab606db1a9307b4aacccdcd1d1a6ef">More...</a><br /></td></tr>
<tr class="separator:ad1ab606db1a9307b4aacccdcd1d1a6ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1a81e3fcbea3045b41ce739a47f54e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#afc1a81e3fcbea3045b41ce739a47f54e">mbedtls_ssl_conf_max_version</a> (<a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf, int major, int minor)</td></tr>
<tr class="memdesc:afc1a81e3fcbea3045b41ce739a47f54e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum supported version sent from the client side and/or accepted at the server side (Default: MBEDTLS_SSL_MAX_MAJOR_VERSION, MBEDTLS_SSL_MAX_MINOR_VERSION)  <a href="../../d4/df9/ssl__tls_8c.html#afc1a81e3fcbea3045b41ce739a47f54e">More...</a><br /></td></tr>
<tr class="separator:afc1a81e3fcbea3045b41ce739a47f54e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eade5c83cc08001672061c5925caaaa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a0eade5c83cc08001672061c5925caaaa">mbedtls_ssl_conf_min_version</a> (<a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf, int major, int minor)</td></tr>
<tr class="memdesc:a0eade5c83cc08001672061c5925caaaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the minimum accepted SSL/TLS protocol version (Default: TLS 1.0)  <a href="../../d4/df9/ssl__tls_8c.html#a0eade5c83cc08001672061c5925caaaa">More...</a><br /></td></tr>
<tr class="separator:a0eade5c83cc08001672061c5925caaaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5a878b9aabe137572a8c73a840c480"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#abb5a878b9aabe137572a8c73a840c480">mbedtls_ssl_conf_fallback</a> (<a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf, char fallback)</td></tr>
<tr class="memdesc:abb5a878b9aabe137572a8c73a840c480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the fallback flag (client-side only). (Default: MBEDTLS_SSL_IS_NOT_FALLBACK).  <a href="../../d4/df9/ssl__tls_8c.html#abb5a878b9aabe137572a8c73a840c480">More...</a><br /></td></tr>
<tr class="separator:abb5a878b9aabe137572a8c73a840c480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05492293c43910a64f746af8f71efb2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a05492293c43910a64f746af8f71efb2f">mbedtls_ssl_conf_cert_req_ca_list</a> (<a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf, char cert_req_ca_list)</td></tr>
<tr class="memdesc:a05492293c43910a64f746af8f71efb2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether to send a list of acceptable CAs in CertificateRequest messages. (Default: do send)  <a href="../../d4/df9/ssl__tls_8c.html#a05492293c43910a64f746af8f71efb2f">More...</a><br /></td></tr>
<tr class="separator:a05492293c43910a64f746af8f71efb2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8a1d55630fec25f2247fc9958eaa53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#afa8a1d55630fec25f2247fc9958eaa53">mbedtls_ssl_conf_encrypt_then_mac</a> (<a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf, char etm)</td></tr>
<tr class="memdesc:afa8a1d55630fec25f2247fc9958eaa53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable Encrypt-then-MAC (Default: MBEDTLS_SSL_ETM_ENABLED)  <a href="../../d4/df9/ssl__tls_8c.html#afa8a1d55630fec25f2247fc9958eaa53">More...</a><br /></td></tr>
<tr class="separator:afa8a1d55630fec25f2247fc9958eaa53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133db91d4a1dd44d212ac57e386c23b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a133db91d4a1dd44d212ac57e386c23b3">mbedtls_ssl_conf_extended_master_secret</a> (<a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf, char ems)</td></tr>
<tr class="memdesc:a133db91d4a1dd44d212ac57e386c23b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable Extended Master Secret negotiation. (Default: MBEDTLS_SSL_EXTENDED_MS_ENABLED)  <a href="../../d4/df9/ssl__tls_8c.html#a133db91d4a1dd44d212ac57e386c23b3">More...</a><br /></td></tr>
<tr class="separator:a133db91d4a1dd44d212ac57e386c23b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e904913a122bd7cb13260217e4cc868"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a9e904913a122bd7cb13260217e4cc868">mbedtls_ssl_conf_arc4_support</a> (<a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf, char arc4)</td></tr>
<tr class="memdesc:a9e904913a122bd7cb13260217e4cc868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable or enable support for RC4 (Default: MBEDTLS_SSL_ARC4_DISABLED)  <a href="../../d4/df9/ssl__tls_8c.html#a9e904913a122bd7cb13260217e4cc868">More...</a><br /></td></tr>
<tr class="separator:a9e904913a122bd7cb13260217e4cc868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68fda83c26b3078e80f4dfc3b09bb94"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#ac68fda83c26b3078e80f4dfc3b09bb94">mbedtls_ssl_conf_max_frag_len</a> (<a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf, unsigned char mfl_code)</td></tr>
<tr class="memdesc:ac68fda83c26b3078e80f4dfc3b09bb94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum fragment length to emit and/or negotiate (Default: the smaller of MBEDTLS_SSL_IN_CONTENT_LEN and MBEDTLS_SSL_OUT_CONTENT_LEN, usually 2^14 bytes) (Server: set maximum fragment length to emit, usually negotiated by the client during handshake (Client: set maximum fragment length to emit <em>and</em> negotiate with the server during handshake)  <a href="../../d4/df9/ssl__tls_8c.html#ac68fda83c26b3078e80f4dfc3b09bb94">More...</a><br /></td></tr>
<tr class="separator:ac68fda83c26b3078e80f4dfc3b09bb94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739b67cfc0350ae4a2c9a2e99737bea7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a739b67cfc0350ae4a2c9a2e99737bea7">mbedtls_ssl_conf_truncated_hmac</a> (<a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf, int truncate)</td></tr>
<tr class="memdesc:a739b67cfc0350ae4a2c9a2e99737bea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate negotiation of truncated HMAC (Default: MBEDTLS_SSL_TRUNC_HMAC_DISABLED)  <a href="../../d4/df9/ssl__tls_8c.html#a739b67cfc0350ae4a2c9a2e99737bea7">More...</a><br /></td></tr>
<tr class="separator:a739b67cfc0350ae4a2c9a2e99737bea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cafaf0e79682a1152838d4991b59e23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a2cafaf0e79682a1152838d4991b59e23">mbedtls_ssl_conf_cbc_record_splitting</a> (<a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf, char split)</td></tr>
<tr class="memdesc:a2cafaf0e79682a1152838d4991b59e23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable / Disable 1/n-1 record splitting (Default: MBEDTLS_SSL_CBC_RECORD_SPLITTING_ENABLED)  <a href="../../d4/df9/ssl__tls_8c.html#a2cafaf0e79682a1152838d4991b59e23">More...</a><br /></td></tr>
<tr class="separator:a2cafaf0e79682a1152838d4991b59e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193c7bf368780f485e20170c807709e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a193c7bf368780f485e20170c807709e5">mbedtls_ssl_conf_legacy_renegotiation</a> (<a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf, int allow_legacy)</td></tr>
<tr class="memdesc:a193c7bf368780f485e20170c807709e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prevent or allow legacy renegotiation. (Default: MBEDTLS_SSL_LEGACY_NO_RENEGOTIATION)  <a href="../../d4/df9/ssl__tls_8c.html#a193c7bf368780f485e20170c807709e5">More...</a><br /></td></tr>
<tr class="separator:a193c7bf368780f485e20170c807709e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad4f50fc1c0a018fd5eb18fd9621d0d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#aad4f50fc1c0a018fd5eb18fd9621d0d3">mbedtls_ssl_conf_renegotiation</a> (<a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf, int renegotiation)</td></tr>
<tr class="memdesc:aad4f50fc1c0a018fd5eb18fd9621d0d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable / Disable renegotiation support for connection when initiated by peer (Default: MBEDTLS_SSL_RENEGOTIATION_DISABLED)  <a href="../../d4/df9/ssl__tls_8c.html#aad4f50fc1c0a018fd5eb18fd9621d0d3">More...</a><br /></td></tr>
<tr class="separator:aad4f50fc1c0a018fd5eb18fd9621d0d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d193b15941a556baaf2cb94138d66df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a2d193b15941a556baaf2cb94138d66df">mbedtls_ssl_conf_renegotiation_enforced</a> (<a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf, int max_records)</td></tr>
<tr class="memdesc:a2d193b15941a556baaf2cb94138d66df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enforce renegotiation requests. (Default: enforced, max_records = 16)  <a href="../../d4/df9/ssl__tls_8c.html#a2d193b15941a556baaf2cb94138d66df">More...</a><br /></td></tr>
<tr class="separator:a2d193b15941a556baaf2cb94138d66df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1785faa0640bd6190c1c17a94b408e31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a1785faa0640bd6190c1c17a94b408e31">mbedtls_ssl_conf_renegotiation_period</a> (<a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf, const unsigned char period[8])</td></tr>
<tr class="memdesc:a1785faa0640bd6190c1c17a94b408e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set record counter threshold for periodic renegotiation. (Default: 2^48 - 1)  <a href="../../d4/df9/ssl__tls_8c.html#a1785faa0640bd6190c1c17a94b408e31">More...</a><br /></td></tr>
<tr class="separator:a1785faa0640bd6190c1c17a94b408e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e547f900979337f4083a8158918fcc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a97e547f900979337f4083a8158918fcc">mbedtls_ssl_conf_session_tickets</a> (<a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf, int use_tickets)</td></tr>
<tr class="memdesc:a97e547f900979337f4083a8158918fcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable / Disable session tickets (client only). (Default: MBEDTLS_SSL_SESSION_TICKETS_ENABLED.)  <a href="../../d4/df9/ssl__tls_8c.html#a97e547f900979337f4083a8158918fcc">More...</a><br /></td></tr>
<tr class="separator:a97e547f900979337f4083a8158918fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f028424df0b3a3b3360df0768df992"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a73f028424df0b3a3b3360df0768df992">mbedtls_ssl_conf_session_tickets_cb</a> (<a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf, <a class="el" href="../../df/d6d/ssl_8h.html#a112d1fc2dd4db788592457d14c0c2899">mbedtls_ssl_ticket_write_t</a> *f_ticket_write, <a class="el" href="../../df/d6d/ssl_8h.html#a48aea353b22e86deece00933ef941536">mbedtls_ssl_ticket_parse_t</a> *f_ticket_parse, void *p_ticket)</td></tr>
<tr class="memdesc:a73f028424df0b3a3b3360df0768df992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure SSL session ticket callbacks (server only). (Default: none.)  <a href="../../d4/df9/ssl__tls_8c.html#a73f028424df0b3a3b3360df0768df992">More...</a><br /></td></tr>
<tr class="separator:a73f028424df0b3a3b3360df0768df992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31125a4db90d3313e17581cb5d6d634"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#ab31125a4db90d3313e17581cb5d6d634">mbedtls_ssl_conf_export_keys_cb</a> (<a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf, <a class="el" href="../../df/d6d/ssl_8h.html#a8f3ea9d32be68d7cd1605f39ce00d697">mbedtls_ssl_export_keys_t</a> *f_export_keys, void *p_export_keys)</td></tr>
<tr class="memdesc:ab31125a4db90d3313e17581cb5d6d634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure key export callback. (Default: none.)  <a href="../../d4/df9/ssl__tls_8c.html#ab31125a4db90d3313e17581cb5d6d634">More...</a><br /></td></tr>
<tr class="separator:ab31125a4db90d3313e17581cb5d6d634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84a75ff85f1bbb7d5e8c7807939fec6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#ae84a75ff85f1bbb7d5e8c7807939fec6">mbedtls_ssl_conf_async_private_cb</a> (<a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf, <a class="el" href="../../df/d6d/ssl_8h.html#ad57308aa77db11dbc3551fd92deb2520">mbedtls_ssl_async_sign_t</a> *f_async_sign, <a class="el" href="../../df/d6d/ssl_8h.html#ac18191035f2598e3311d24a3ae40a0fa">mbedtls_ssl_async_decrypt_t</a> *f_async_decrypt, <a class="el" href="../../df/d6d/ssl_8h.html#a6a67de0c00f4aff4500ece33645a96cd">mbedtls_ssl_async_resume_t</a> *f_async_resume, <a class="el" href="../../df/d6d/ssl_8h.html#a084ed94ac531cfde7dcd0d0c05d392bd">mbedtls_ssl_async_cancel_t</a> *f_async_cancel, void *async_config_data)</td></tr>
<tr class="memdesc:ae84a75ff85f1bbb7d5e8c7807939fec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure asynchronous private key operation callbacks.  <a href="../../d4/df9/ssl__tls_8c.html#ae84a75ff85f1bbb7d5e8c7807939fec6">More...</a><br /></td></tr>
<tr class="separator:ae84a75ff85f1bbb7d5e8c7807939fec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a374a41575f2f8a478bda3479772f943c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a374a41575f2f8a478bda3479772f943c">mbedtls_ssl_conf_get_async_config_data</a> (const <a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf)</td></tr>
<tr class="memdesc:a374a41575f2f8a478bda3479772f943c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the configuration data set by <a class="el" href="../../df/d6d/ssl_8h.html#a0675aed5a2b2b9ff219a62ed28b50819" title="Configure asynchronous private key operation callbacks.">mbedtls_ssl_conf_async_private_cb()</a>.  <a href="../../d4/df9/ssl__tls_8c.html#a374a41575f2f8a478bda3479772f943c">More...</a><br /></td></tr>
<tr class="separator:a374a41575f2f8a478bda3479772f943c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e424db2d8ccc9f0d5fe4ed0a9a5bab2"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a7e424db2d8ccc9f0d5fe4ed0a9a5bab2">mbedtls_ssl_get_async_operation_data</a> (const <a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl)</td></tr>
<tr class="memdesc:a7e424db2d8ccc9f0d5fe4ed0a9a5bab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the asynchronous operation user context.  <a href="../../d4/df9/ssl__tls_8c.html#a7e424db2d8ccc9f0d5fe4ed0a9a5bab2">More...</a><br /></td></tr>
<tr class="separator:a7e424db2d8ccc9f0d5fe4ed0a9a5bab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57fb2abf2a5cd821d0ec8c3d6c59daf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#ac57fb2abf2a5cd821d0ec8c3d6c59daf">mbedtls_ssl_set_async_operation_data</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl, void *ctx)</td></tr>
<tr class="memdesc:ac57fb2abf2a5cd821d0ec8c3d6c59daf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the asynchronous operation user context.  <a href="../../d4/df9/ssl__tls_8c.html#ac57fb2abf2a5cd821d0ec8c3d6c59daf">More...</a><br /></td></tr>
<tr class="separator:ac57fb2abf2a5cd821d0ec8c3d6c59daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43142085f3182e9b0dc967ec582032b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#ad43142085f3182e9b0dc967ec582032b">mbedtls_ssl_get_bytes_avail</a> (const <a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl)</td></tr>
<tr class="memdesc:ad43142085f3182e9b0dc967ec582032b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of application data bytes remaining to be read from the current record.  <a href="../../d4/df9/ssl__tls_8c.html#ad43142085f3182e9b0dc967ec582032b">More...</a><br /></td></tr>
<tr class="separator:ad43142085f3182e9b0dc967ec582032b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4075f7de9877fd667bcfa2e819e33426"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a4075f7de9877fd667bcfa2e819e33426">mbedtls_ssl_check_pending</a> (const <a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl)</td></tr>
<tr class="memdesc:a4075f7de9877fd667bcfa2e819e33426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if there is data already read from the underlying transport but not yet processed.  <a href="../../d4/df9/ssl__tls_8c.html#a4075f7de9877fd667bcfa2e819e33426">More...</a><br /></td></tr>
<tr class="separator:a4075f7de9877fd667bcfa2e819e33426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516064f1468d459159ef7cd6c496a026"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a516064f1468d459159ef7cd6c496a026">mbedtls_ssl_get_verify_result</a> (const <a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl)</td></tr>
<tr class="memdesc:a516064f1468d459159ef7cd6c496a026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of the certificate verification.  <a href="../../d4/df9/ssl__tls_8c.html#a516064f1468d459159ef7cd6c496a026">More...</a><br /></td></tr>
<tr class="separator:a516064f1468d459159ef7cd6c496a026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18739598df499461369020b8ea6fff1c"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a18739598df499461369020b8ea6fff1c">mbedtls_ssl_get_ciphersuite</a> (const <a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl)</td></tr>
<tr class="memdesc:a18739598df499461369020b8ea6fff1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name of the current ciphersuite.  <a href="../../d4/df9/ssl__tls_8c.html#a18739598df499461369020b8ea6fff1c">More...</a><br /></td></tr>
<tr class="separator:a18739598df499461369020b8ea6fff1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee2e52fe2ae9620af84df97a0347ce3"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a1ee2e52fe2ae9620af84df97a0347ce3">mbedtls_ssl_get_version</a> (const <a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl)</td></tr>
<tr class="memdesc:a1ee2e52fe2ae9620af84df97a0347ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current SSL version (SSLv3/TLSv1/etc)  <a href="../../d4/df9/ssl__tls_8c.html#a1ee2e52fe2ae9620af84df97a0347ce3">More...</a><br /></td></tr>
<tr class="separator:a1ee2e52fe2ae9620af84df97a0347ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935f3ebfb31f988e24a8bf9bcb0fd26b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a935f3ebfb31f988e24a8bf9bcb0fd26b">mbedtls_ssl_get_record_expansion</a> (const <a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl)</td></tr>
<tr class="memdesc:a935f3ebfb31f988e24a8bf9bcb0fd26b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the (maximum) number of bytes added by the record layer: header + encryption/MAC overhead (inc. padding)  <a href="../../d4/df9/ssl__tls_8c.html#a935f3ebfb31f988e24a8bf9bcb0fd26b">More...</a><br /></td></tr>
<tr class="separator:a935f3ebfb31f988e24a8bf9bcb0fd26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44fb4dcf45412d667778432836be9150"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a44fb4dcf45412d667778432836be9150">mbedtls_ssl_get_max_frag_len</a> (const <a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl)</td></tr>
<tr class="memdesc:a44fb4dcf45412d667778432836be9150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum fragment length (payload, in bytes). This is the value negotiated with peer if any, or the locally configured value.  <a href="../../d4/df9/ssl__tls_8c.html#a44fb4dcf45412d667778432836be9150">More...</a><br /></td></tr>
<tr class="separator:a44fb4dcf45412d667778432836be9150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a7ddcf453791f2947bc7f99503047d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a58a7ddcf453791f2947bc7f99503047d">mbedtls_ssl_get_max_out_record_payload</a> (const <a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl)</td></tr>
<tr class="memdesc:a58a7ddcf453791f2947bc7f99503047d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current maximum outgoing record payload in bytes. This takes into account the <a class="el" href="../../db/d16/config_8h.html" title="Configuration options (set of defines)">config.h</a> setting <code>MBEDTLS_SSL_OUT_CONTENT_LEN</code>, the configured and negotiated max fragment length extension if used, and for DTLS the path MTU as configured and current record expansion.  <a href="../../d4/df9/ssl__tls_8c.html#a58a7ddcf453791f2947bc7f99503047d">More...</a><br /></td></tr>
<tr class="separator:a58a7ddcf453791f2947bc7f99503047d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ab0ac8d8341063a0f815ee99337831"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d6/daa/structmbedtls__x509__crt.html">mbedtls_x509_crt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#aa7ab0ac8d8341063a0f815ee99337831">mbedtls_ssl_get_peer_cert</a> (const <a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl)</td></tr>
<tr class="memdesc:aa7ab0ac8d8341063a0f815ee99337831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the peer certificate from the current connection.  <a href="../../d4/df9/ssl__tls_8c.html#aa7ab0ac8d8341063a0f815ee99337831">More...</a><br /></td></tr>
<tr class="separator:aa7ab0ac8d8341063a0f815ee99337831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac583292bcb5db73c00b7350a7c2a79a2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#ac583292bcb5db73c00b7350a7c2a79a2">mbedtls_ssl_get_session</a> (const <a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl, <a class="el" href="../../da/def/structmbedtls__ssl__session.html">mbedtls_ssl_session</a> *dst)</td></tr>
<tr class="memdesc:ac583292bcb5db73c00b7350a7c2a79a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save session in order to resume it later (client-side only) Session data is copied to presented session structure.  <a href="../../d4/df9/ssl__tls_8c.html#ac583292bcb5db73c00b7350a7c2a79a2">More...</a><br /></td></tr>
<tr class="separator:ac583292bcb5db73c00b7350a7c2a79a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1583fe56eda081580742999968bbcf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#aac1583fe56eda081580742999968bbcf">mbedtls_ssl_handshake_step</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl)</td></tr>
<tr class="memdesc:aac1583fe56eda081580742999968bbcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a single step of the SSL handshake.  <a href="../../d4/df9/ssl__tls_8c.html#aac1583fe56eda081580742999968bbcf">More...</a><br /></td></tr>
<tr class="separator:aac1583fe56eda081580742999968bbcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a37e497cd08c896870a42b1b618186e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a4a37e497cd08c896870a42b1b618186e">mbedtls_ssl_handshake</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl)</td></tr>
<tr class="memdesc:a4a37e497cd08c896870a42b1b618186e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the SSL handshake.  <a href="../../d4/df9/ssl__tls_8c.html#a4a37e497cd08c896870a42b1b618186e">More...</a><br /></td></tr>
<tr class="separator:a4a37e497cd08c896870a42b1b618186e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b7a27a616495d5f0a4fabc3f550dbb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a49b7a27a616495d5f0a4fabc3f550dbb">mbedtls_ssl_renegotiate</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl)</td></tr>
<tr class="memdesc:a49b7a27a616495d5f0a4fabc3f550dbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiate an SSL renegotiation on the running connection. Client: perform the renegotiation right now. Server: request renegotiation, which will be performed during the next call to <a class="el" href="../../df/d6d/ssl_8h.html#aa2c29eeb1deaf5ad9f01a7515006ede5" title="Read at most &#39;len&#39; application data bytes.">mbedtls_ssl_read()</a> if honored by client.  <a href="../../d4/df9/ssl__tls_8c.html#a49b7a27a616495d5f0a4fabc3f550dbb">More...</a><br /></td></tr>
<tr class="separator:a49b7a27a616495d5f0a4fabc3f550dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2c29eeb1deaf5ad9f01a7515006ede5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#aa2c29eeb1deaf5ad9f01a7515006ede5">mbedtls_ssl_read</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl, unsigned char *buf, size_t len)</td></tr>
<tr class="memdesc:aa2c29eeb1deaf5ad9f01a7515006ede5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read at most 'len' application data bytes.  <a href="../../d4/df9/ssl__tls_8c.html#aa2c29eeb1deaf5ad9f01a7515006ede5">More...</a><br /></td></tr>
<tr class="separator:aa2c29eeb1deaf5ad9f01a7515006ede5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bbda87d484de82df730758b475f32e5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a5bbda87d484de82df730758b475f32e5">mbedtls_ssl_write</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl, const unsigned char *buf, size_t len)</td></tr>
<tr class="memdesc:a5bbda87d484de82df730758b475f32e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to write exactly 'len' application data bytes.  <a href="../../d4/df9/ssl__tls_8c.html#a5bbda87d484de82df730758b475f32e5">More...</a><br /></td></tr>
<tr class="separator:a5bbda87d484de82df730758b475f32e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c1b17128ead2df3082e27b603deb4c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#ac2c1b17128ead2df3082e27b603deb4c">mbedtls_ssl_close_notify</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl)</td></tr>
<tr class="memdesc:ac2c1b17128ead2df3082e27b603deb4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify the peer that the connection is being closed.  <a href="../../d4/df9/ssl__tls_8c.html#ac2c1b17128ead2df3082e27b603deb4c">More...</a><br /></td></tr>
<tr class="separator:ac2c1b17128ead2df3082e27b603deb4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d2364679f41031b1c26ef50731e76fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a2d2364679f41031b1c26ef50731e76fb">mbedtls_ssl_transform_free</a> (<a class="el" href="../../df/d5d/structmbedtls__ssl__transform.html">mbedtls_ssl_transform</a> *transform)</td></tr>
<tr class="memdesc:a2d2364679f41031b1c26ef50731e76fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free referenced items in an SSL transform context and clear memory.  <a href="../../d4/df9/ssl__tls_8c.html#a2d2364679f41031b1c26ef50731e76fb">More...</a><br /></td></tr>
<tr class="separator:a2d2364679f41031b1c26ef50731e76fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15fc29ce95f7f0f0f5f9571ddb38ea9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a15fc29ce95f7f0f0f5f9571ddb38ea9e">mbedtls_ssl_handshake_free</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl)</td></tr>
<tr class="memdesc:a15fc29ce95f7f0f0f5f9571ddb38ea9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free referenced items in an SSL handshake context and clear memory.  <a href="../../d4/df9/ssl__tls_8c.html#a15fc29ce95f7f0f0f5f9571ddb38ea9e">More...</a><br /></td></tr>
<tr class="separator:a15fc29ce95f7f0f0f5f9571ddb38ea9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac085defe1a02ab784a0a2fb201bcc741"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#ac085defe1a02ab784a0a2fb201bcc741">mbedtls_ssl_session_free</a> (<a class="el" href="../../da/def/structmbedtls__ssl__session.html">mbedtls_ssl_session</a> *session)</td></tr>
<tr class="memdesc:ac085defe1a02ab784a0a2fb201bcc741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free referenced items in an SSL session including the peer certificate and clear memory.  <a href="../../d4/df9/ssl__tls_8c.html#ac085defe1a02ab784a0a2fb201bcc741">More...</a><br /></td></tr>
<tr class="separator:ac085defe1a02ab784a0a2fb201bcc741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc104a181bcd11eafbbf7e6923978bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a2dc104a181bcd11eafbbf7e6923978bc">mbedtls_ssl_free</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl)</td></tr>
<tr class="memdesc:a2dc104a181bcd11eafbbf7e6923978bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free referenced items in an SSL context and clear memory.  <a href="../../d4/df9/ssl__tls_8c.html#a2dc104a181bcd11eafbbf7e6923978bc">More...</a><br /></td></tr>
<tr class="separator:a2dc104a181bcd11eafbbf7e6923978bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba55bcda50a47e83803e31a8db7c9a86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#aba55bcda50a47e83803e31a8db7c9a86">mbedtls_ssl_config_init</a> (<a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf)</td></tr>
<tr class="memdesc:aba55bcda50a47e83803e31a8db7c9a86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an SSL configuration context Just makes the context ready for <a class="el" href="../../df/d6d/ssl_8h.html#aa1335b65ba57e81accc91ef95454d5a6" title="Load reasonnable default SSL configuration values. (You need to call mbedtls_ssl_config_init() first....">mbedtls_ssl_config_defaults()</a> or <a class="el" href="../../df/d6d/ssl_8h.html#a7655f025440a6c5ccd4fc13832abb1dd" title="Free an SSL configuration context.">mbedtls_ssl_config_free()</a>.  <a href="../../d4/df9/ssl__tls_8c.html#aba55bcda50a47e83803e31a8db7c9a86">More...</a><br /></td></tr>
<tr class="separator:aba55bcda50a47e83803e31a8db7c9a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1335b65ba57e81accc91ef95454d5a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#aa1335b65ba57e81accc91ef95454d5a6">mbedtls_ssl_config_defaults</a> (<a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf, int endpoint, int transport, int preset)</td></tr>
<tr class="memdesc:aa1335b65ba57e81accc91ef95454d5a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load reasonnable default SSL configuration values. (You need to call <a class="el" href="../../df/d6d/ssl_8h.html#aba55bcda50a47e83803e31a8db7c9a86" title="Initialize an SSL configuration context Just makes the context ready for mbedtls_ssl_config_defaults(...">mbedtls_ssl_config_init()</a> first.)  <a href="../../d4/df9/ssl__tls_8c.html#aa1335b65ba57e81accc91ef95454d5a6">More...</a><br /></td></tr>
<tr class="separator:aa1335b65ba57e81accc91ef95454d5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7655f025440a6c5ccd4fc13832abb1dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a7655f025440a6c5ccd4fc13832abb1dd">mbedtls_ssl_config_free</a> (<a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *conf)</td></tr>
<tr class="memdesc:a7655f025440a6c5ccd4fc13832abb1dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free an SSL configuration context.  <a href="../../d4/df9/ssl__tls_8c.html#a7655f025440a6c5ccd4fc13832abb1dd">More...</a><br /></td></tr>
<tr class="separator:a7655f025440a6c5ccd4fc13832abb1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af084cb7351cb61bf6e97acd2bb4f9cd2"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#af084cb7351cb61bf6e97acd2bb4f9cd2">mbedtls_ssl_sig_from_pk</a> (<a class="el" href="../../d0/d1b/structmbedtls__pk__context.html">mbedtls_pk_context</a> *pk)</td></tr>
<tr class="separator:af084cb7351cb61bf6e97acd2bb4f9cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315536e7dc02769c9ee562f68d6ebd70"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a315536e7dc02769c9ee562f68d6ebd70">mbedtls_ssl_sig_from_pk_alg</a> (<a class="el" href="../../d1/dd6/pk_8h.html#a3fe41eff5605ae727eb9d28dad297020">mbedtls_pk_type_t</a> type)</td></tr>
<tr class="separator:a315536e7dc02769c9ee562f68d6ebd70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06fac477160b85cb5b4dc325de933a30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dd6/pk_8h.html#a3fe41eff5605ae727eb9d28dad297020">mbedtls_pk_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a06fac477160b85cb5b4dc325de933a30">mbedtls_ssl_pk_alg_from_sig</a> (unsigned char sig)</td></tr>
<tr class="separator:a06fac477160b85cb5b4dc325de933a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40fe4e983b1baa16ddd3b45894c0c932"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dbf/md_8h.html#a219313cb40503ec3e34a857ab98b2296">mbedtls_md_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a40fe4e983b1baa16ddd3b45894c0c932">mbedtls_ssl_sig_hash_set_find</a> (<a class="el" href="../../db/d21/structmbedtls__ssl__sig__hash__set__t.html">mbedtls_ssl_sig_hash_set_t</a> *set, <a class="el" href="../../d1/dd6/pk_8h.html#a3fe41eff5605ae727eb9d28dad297020">mbedtls_pk_type_t</a> sig_alg)</td></tr>
<tr class="separator:a40fe4e983b1baa16ddd3b45894c0c932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa145b4b8342e17bd7e2457a4e73c51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#abaa145b4b8342e17bd7e2457a4e73c51">mbedtls_ssl_sig_hash_set_add</a> (<a class="el" href="../../db/d21/structmbedtls__ssl__sig__hash__set__t.html">mbedtls_ssl_sig_hash_set_t</a> *set, <a class="el" href="../../d1/dd6/pk_8h.html#a3fe41eff5605ae727eb9d28dad297020">mbedtls_pk_type_t</a> sig_alg, <a class="el" href="../../d8/dbf/md_8h.html#a219313cb40503ec3e34a857ab98b2296">mbedtls_md_type_t</a> md_alg)</td></tr>
<tr class="separator:abaa145b4b8342e17bd7e2457a4e73c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067168987e892b97cef9e31599cadc3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a067168987e892b97cef9e31599cadc3f">mbedtls_ssl_sig_hash_set_const_hash</a> (<a class="el" href="../../db/d21/structmbedtls__ssl__sig__hash__set__t.html">mbedtls_ssl_sig_hash_set_t</a> *set, <a class="el" href="../../d8/dbf/md_8h.html#a219313cb40503ec3e34a857ab98b2296">mbedtls_md_type_t</a> md_alg)</td></tr>
<tr class="separator:a067168987e892b97cef9e31599cadc3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38919961fbabe3adb94c5798d1dc9610"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/dbf/md_8h.html#a219313cb40503ec3e34a857ab98b2296">mbedtls_md_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a38919961fbabe3adb94c5798d1dc9610">mbedtls_ssl_md_alg_from_hash</a> (unsigned char hash)</td></tr>
<tr class="separator:a38919961fbabe3adb94c5798d1dc9610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac895f60c4cd63713bdfa3336084f1e5b"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#ac895f60c4cd63713bdfa3336084f1e5b">mbedtls_ssl_hash_from_md_alg</a> (int md)</td></tr>
<tr class="separator:ac895f60c4cd63713bdfa3336084f1e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7bfd81f7c8c03c875d8028169e2407e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#ae7bfd81f7c8c03c875d8028169e2407e">mbedtls_ssl_check_curve</a> (const <a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl, <a class="el" href="../../de/df7/ecp_8h.html#af79e530ea8f8416480f805baa20b1a2d">mbedtls_ecp_group_id</a> grp_id)</td></tr>
<tr class="separator:ae7bfd81f7c8c03c875d8028169e2407e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84159147b73016145706a3dc247621c1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a84159147b73016145706a3dc247621c1">mbedtls_ssl_check_sig_hash</a> (const <a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl, <a class="el" href="../../d8/dbf/md_8h.html#a219313cb40503ec3e34a857ab98b2296">mbedtls_md_type_t</a> md)</td></tr>
<tr class="separator:a84159147b73016145706a3dc247621c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd3c0caa2ad38ece4a1a0ad08ccd059"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a5dd3c0caa2ad38ece4a1a0ad08ccd059">mbedtls_ssl_check_cert_usage</a> (const <a class="el" href="../../d6/daa/structmbedtls__x509__crt.html">mbedtls_x509_crt</a> *cert, const <a class="el" href="../../dd/d7a/structmbedtls__ssl__ciphersuite__t.html">mbedtls_ssl_ciphersuite_t</a> *ciphersuite, int cert_endpoint, uint32_t *flags)</td></tr>
<tr class="separator:a5dd3c0caa2ad38ece4a1a0ad08ccd059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7438e9eb43bbfc167ff48ccfaab033"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a4f7438e9eb43bbfc167ff48ccfaab033">mbedtls_ssl_write_version</a> (int major, int minor, int transport, unsigned char ver[2])</td></tr>
<tr class="separator:a4f7438e9eb43bbfc167ff48ccfaab033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b290906063a6e619cee055f881580fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a7b290906063a6e619cee055f881580fe">mbedtls_ssl_read_version</a> (int *major, int *minor, int transport, const unsigned char ver[2])</td></tr>
<tr class="separator:a7b290906063a6e619cee055f881580fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac932e0439258a97117482fe38e59eaff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#ac932e0439258a97117482fe38e59eaff">mbedtls_ssl_set_calc_verify_md</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl, int md)</td></tr>
<tr class="separator:ac932e0439258a97117482fe38e59eaff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad56448eab60a42579427eed05bfa69d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#ad56448eab60a42579427eed05bfa69d1">mbedtls_ssl_get_key_exchange_md_ssl_tls</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl, unsigned char *output, unsigned char *data, size_t data_len)</td></tr>
<tr class="separator:ad56448eab60a42579427eed05bfa69d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3aa894a685365d2234a3571dc2ba14b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#ad3aa894a685365d2234a3571dc2ba14b">mbedtls_ssl_get_key_exchange_md_tls1_2</a> (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl, unsigned char *hash, size_t *hashlen, unsigned char *data, size_t data_len, <a class="el" href="../../d8/dbf/md_8h.html#a219313cb40503ec3e34a857ab98b2296">mbedtls_md_type_t</a> md_alg)</td></tr>
<tr class="separator:ad3aa894a685365d2234a3571dc2ba14b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a5b2092401b8076dabc962911b0758cff"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a5b2092401b8076dabc962911b0758cff">mbedtls_ssl_hw_record_init</a> )(<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl, const unsigned char *key_enc, const unsigned char *key_dec, size_t keylen, const unsigned char *iv_enc, const unsigned char *iv_dec, size_t ivlen, const unsigned char *mac_enc, const unsigned char *mac_dec, size_t maclen) = NULL</td></tr>
<tr class="separator:a5b2092401b8076dabc962911b0758cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac364a9fc4d0342743cbe0a0a5c242f2c"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#ac364a9fc4d0342743cbe0a0a5c242f2c">mbedtls_ssl_hw_record_activate</a> )(<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl, int direction) = NULL</td></tr>
<tr class="separator:ac364a9fc4d0342743cbe0a0a5c242f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e3fc02bc07e01521db4fc3019e47e5c"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a7e3fc02bc07e01521db4fc3019e47e5c">mbedtls_ssl_hw_record_reset</a> )(<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl) = NULL</td></tr>
<tr class="separator:a7e3fc02bc07e01521db4fc3019e47e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae65226ba7a00590e47b0fe8b295df8d1"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#ae65226ba7a00590e47b0fe8b295df8d1">mbedtls_ssl_hw_record_write</a> )(<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl) = NULL</td></tr>
<tr class="separator:ae65226ba7a00590e47b0fe8b295df8d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b997dbd2572e5217b3e438f8576e6f4"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#a4b997dbd2572e5217b3e438f8576e6f4">mbedtls_ssl_hw_record_read</a> )(<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl) = NULL</td></tr>
<tr class="separator:a4b997dbd2572e5217b3e438f8576e6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac535a2f5139611bc45242460f48bfcdf"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df9/ssl__tls_8c.html#ac535a2f5139611bc45242460f48bfcdf">mbedtls_ssl_hw_record_finish</a> )(<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl) = NULL</td></tr>
<tr class="separator:ac535a2f5139611bc45242460f48bfcdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a4b188ac79655c2940f088fa8ea5eb47a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b188ac79655c2940f088fa8ea5eb47a">&#9670;&nbsp;</a></span>mbedtls_ssl_derive_keys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_derive_keys </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/df9/ssl__tls_8c_a4b188ac79655c2940f088fa8ea5eb47a_cgraph.png" border="0" usemap="#ad4/df9/ssl__tls_8c_a4b188ac79655c2940f088fa8ea5eb47a_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="aebd72b8a9403870505bba5829fa1a00b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd72b8a9403870505bba5829fa1a00b">&#9670;&nbsp;</a></span>ssl_calc_verify_ssl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ssl_calc_verify_ssl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>hash</em>[36]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/df9/ssl__tls_8c_aebd72b8a9403870505bba5829fa1a00b_cgraph.png" border="0" usemap="#ad4/df9/ssl__tls_8c_aebd72b8a9403870505bba5829fa1a00b_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a5529a8422a9cd4ed7a3503e6e11c7042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5529a8422a9cd4ed7a3503e6e11c7042">&#9670;&nbsp;</a></span>ssl_calc_verify_tls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ssl_calc_verify_tls </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>hash</em>[36]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/df9/ssl__tls_8c_a5529a8422a9cd4ed7a3503e6e11c7042_cgraph.png" border="0" usemap="#ad4/df9/ssl__tls_8c_a5529a8422a9cd4ed7a3503e6e11c7042_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a95d29022ea4cc8da03957fcda703e2d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d29022ea4cc8da03957fcda703e2d8">&#9670;&nbsp;</a></span>ssl_calc_verify_tls_sha256()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ssl_calc_verify_tls_sha256 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>hash</em>[32]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/df9/ssl__tls_8c_a95d29022ea4cc8da03957fcda703e2d8_cgraph.png" border="0" usemap="#ad4/df9/ssl__tls_8c_a95d29022ea4cc8da03957fcda703e2d8_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a23aee11f334c5dc7e18ddc9705f89a6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23aee11f334c5dc7e18ddc9705f89a6e">&#9670;&nbsp;</a></span>ssl_calc_verify_tls_sha384()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ssl_calc_verify_tls_sha384 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>hash</em>[48]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/df9/ssl__tls_8c_a23aee11f334c5dc7e18ddc9705f89a6e_cgraph.png" border="0" usemap="#ad4/df9/ssl__tls_8c_a23aee11f334c5dc7e18ddc9705f89a6e_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a9518f4ada60690c9fb45a8576e8a9925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9518f4ada60690c9fb45a8576e8a9925">&#9670;&nbsp;</a></span>mbedtls_ssl_psk_derive_premaster()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_psk_derive_premaster </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/d01/ssl__ciphersuites_8h.html#ae04606bda9a15cfd8bd51c2f6fd52a3a">mbedtls_key_exchange_type_t</a>&#160;</td>
          <td class="paramname"><em>key_ex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/df9/ssl__tls_8c_a9518f4ada60690c9fb45a8576e8a9925_cgraph.png" border="0" usemap="#ad4/df9/ssl__tls_8c_a9518f4ada60690c9fb45a8576e8a9925_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a28834d530cc3814037af2e998300535f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28834d530cc3814037af2e998300535f">&#9670;&nbsp;</a></span>mbedtls_ssl_fetch_input()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_fetch_input </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nb_want</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae06b33ccfcd45627a80fd851e608ebff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae06b33ccfcd45627a80fd851e608ebff">&#9670;&nbsp;</a></span>mbedtls_ssl_flush_output()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_flush_output </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acf2247e73d226008173334d8f74e91c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf2247e73d226008173334d8f74e91c7">&#9670;&nbsp;</a></span>mbedtls_ssl_resend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_resend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/df9/ssl__tls_8c_acf2247e73d226008173334d8f74e91c7_cgraph.png" border="0" usemap="#ad4/df9/ssl__tls_8c_acf2247e73d226008173334d8f74e91c7_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a10a68cbd0dd94c8e85b1f58a0a358138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10a68cbd0dd94c8e85b1f58a0a358138">&#9670;&nbsp;</a></span>mbedtls_ssl_flight_transmit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_flight_transmit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af81065530f05242ebf432dd842037bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af81065530f05242ebf432dd842037bf5">&#9670;&nbsp;</a></span>mbedtls_ssl_recv_flight_completed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_recv_flight_completed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0fcf940a335d71a7896591da175cca50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fcf940a335d71a7896591da175cca50">&#9670;&nbsp;</a></span>mbedtls_ssl_send_flight_completed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_send_flight_completed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8fe627c62fdc4ba7225f59b7f1596a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fe627c62fdc4ba7225f59b7f1596a95">&#9670;&nbsp;</a></span>mbedtls_ssl_write_handshake_msg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_write_handshake_msg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a56dba26b0d35cd109798849dd8d9e304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56dba26b0d35cd109798849dd8d9e304">&#9670;&nbsp;</a></span>mbedtls_ssl_write_record()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_write_record </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>force_flush</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a356520cef18fad75652d4d115d310c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a356520cef18fad75652d4d115d310c76">&#9670;&nbsp;</a></span>mbedtls_ssl_prepare_handshake_record()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_prepare_handshake_record </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="addad18433e4cb4392a1f0cdec16103de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addad18433e4cb4392a1f0cdec16103de">&#9670;&nbsp;</a></span>mbedtls_ssl_update_handshake_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_update_handshake_status </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a54cf83f503ba4bb7bc0a0a0a4ae259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a54cf83f503ba4bb7bc0a0a0a4ae259">&#9670;&nbsp;</a></span>mbedtls_ssl_dtls_replay_check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_dtls_replay_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f44a6f167e74e6e5d71a6ee740a3b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f44a6f167e74e6e5d71a6ee740a3b57">&#9670;&nbsp;</a></span>mbedtls_ssl_dtls_replay_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_dtls_replay_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ace66a0d800c2e5cddfcd8d62aa675f7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace66a0d800c2e5cddfcd8d62aa675f7c">&#9670;&nbsp;</a></span>mbedtls_ssl_read_record()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_read_record </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>update_hs_digest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update record layer. </p>
<pre class="fragment">         This function roughly separates the implementation
         of the logic of (D)TLS from the implementation
         of the secure transport.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>The SSL context to use. </td></tr>
    <tr><td class="paramname">update_hs_digest</td><td>This indicates if the handshake digest should be automatically updated in case a handshake message is found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 or non-zero error code.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>A clarification on what is called 'record layer' here is in order, as many sensible definitions are possible:</dd></dl>
<p>The record layer takes as input an untrusted underlying transport (stream or datagram) and transforms it into a serially multiplexed, secure transport, which conceptually provides the following:</p>
<p>(1) Three datagram based, content-agnostic transports for handshake, alert and CCS messages. (2) One stream- or datagram-based transport for application data. (3) Functionality for changing the underlying transform securing the contents.</p>
<p>The interface to this functionality is given as follows:</p>
<p>a Updating [Currently implemented by mbedtls_ssl_read_record]</p>
<p>Check if and on which of the four 'ports' data is pending: Nothing, a controlling datagram of type (1), or application data (2). In any case data is present, internal buffers provide access to the data for the user to process it. Consumption of type (1) datagrams is done automatically on the next update, invalidating that the internal buffers for previous datagrams, while consumption of application data (2) is user-controlled.</p>
<p>b Reading of application data [Currently manual adaption of ssl-&gt;in_offt pointer]</p>
<p>As mentioned in the last paragraph, consumption of data is different from the automatic consumption of control datagrams (1) because application data is treated as a stream.</p>
<p>c Tracking availability of application data [Currently manually through decreasing ssl-&gt;in_msglen]</p>
<p>For efficiency and to retain datagram semantics for application data in case of DTLS, the record layer provides functionality for checking how much application data is still available in the internal buffer.</p>
<p>d Changing the transformation securing the communication.</p>
<p>Given an opaque implementation of the record layer in the above sense, it should be possible to implement the logic of (D)TLS on top of it without the need to know anything about the record layer's internals. This is done e.g. in all the handshake handling functions, and in the application data reading function mbedtls_ssl_read.</p>
<dl class="section note"><dt>Note</dt><dd>The above tries to give a conceptual picture of the record layer, but the current implementation deviates from it in some places. For example, our implementation of the update functionality through mbedtls_ssl_read_record discards datagrams depending on the current state, which wouldn't fall under the record layer's responsibility following the above definition. </dd></dl>

</div>
</div>
<a id="ac74140ac05c1ae66adbd4a8cb62451ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74140ac05c1ae66adbd4a8cb62451ee">&#9670;&nbsp;</a></span>mbedtls_ssl_handle_message_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_handle_message_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/df9/ssl__tls_8c_ac74140ac05c1ae66adbd4a8cb62451ee_cgraph.png" border="0" usemap="#ad4/df9/ssl__tls_8c_ac74140ac05c1ae66adbd4a8cb62451ee_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="ac8abadab965dc3e658c2771b30244b4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8abadab965dc3e658c2771b30244b4c">&#9670;&nbsp;</a></span>mbedtls_ssl_send_fatal_handshake_failure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_send_fatal_handshake_failure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/df9/ssl__tls_8c_ac8abadab965dc3e658c2771b30244b4c_cgraph.png" border="0" usemap="#ad4/df9/ssl__tls_8c_ac8abadab965dc3e658c2771b30244b4c_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a431e67252731a34bd9b5f2c9222f4c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a431e67252731a34bd9b5f2c9222f4c43">&#9670;&nbsp;</a></span>mbedtls_ssl_send_alert_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_send_alert_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send an alert message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>SSL context </td></tr>
    <tr><td class="paramname">level</td><td>The alert level of the message (MBEDTLS_SSL_ALERT_LEVEL_WARNING or MBEDTLS_SSL_ALERT_LEVEL_FATAL) </td></tr>
    <tr><td class="paramname">message</td><td>The alert message (SSL_ALERT_MSG_*)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or a specific SSL error code.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If this function returns something other than 0 or MBEDTLS_ERR_SSL_WANT_READ/WRITE, you must stop using the SSL context for reading or writing, and either free it or call <code><a class="el" href="../../df/d6d/ssl_8h.html#a21432367cbce428f10dcb62d9456fa7e" title="Reset an already initialized SSL context for re-use while retaining application-set variables,...">mbedtls_ssl_session_reset()</a></code> on it before re-using it for a new connection; the current connection must be closed. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/df9/ssl__tls_8c_a431e67252731a34bd9b5f2c9222f4c43_cgraph.png" border="0" usemap="#ad4/df9/ssl__tls_8c_a431e67252731a34bd9b5f2c9222f4c43_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="ad5d10db1fb3bd2b514124fe411b4e030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5d10db1fb3bd2b514124fe411b4e030">&#9670;&nbsp;</a></span>mbedtls_ssl_write_certificate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_write_certificate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a84dc812afc4e0b8c71e4df27abed114a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84dc812afc4e0b8c71e4df27abed114a">&#9670;&nbsp;</a></span>mbedtls_ssl_parse_certificate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_parse_certificate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/df9/ssl__tls_8c_a84dc812afc4e0b8c71e4df27abed114a_cgraph.png" border="0" usemap="#ad4/df9/ssl__tls_8c_a84dc812afc4e0b8c71e4df27abed114a_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a0ae2eeddd9d9b7a974cfa89add112288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ae2eeddd9d9b7a974cfa89add112288">&#9670;&nbsp;</a></span>mbedtls_ssl_write_change_cipher_spec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_write_change_cipher_spec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/df9/ssl__tls_8c_a0ae2eeddd9d9b7a974cfa89add112288_cgraph.png" border="0" usemap="#ad4/df9/ssl__tls_8c_a0ae2eeddd9d9b7a974cfa89add112288_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="ab99ea2532d111be262e1d528dbd67a3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab99ea2532d111be262e1d528dbd67a3b">&#9670;&nbsp;</a></span>mbedtls_ssl_parse_change_cipher_spec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_parse_change_cipher_spec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/df9/ssl__tls_8c_ab99ea2532d111be262e1d528dbd67a3b_cgraph.png" border="0" usemap="#ad4/df9/ssl__tls_8c_ab99ea2532d111be262e1d528dbd67a3b_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="ab0271511696869c311621c09d3373e47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0271511696869c311621c09d3373e47">&#9670;&nbsp;</a></span>mbedtls_ssl_optimize_checksum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_optimize_checksum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d7a/structmbedtls__ssl__ciphersuite__t.html">mbedtls_ssl_ciphersuite_t</a> *&#160;</td>
          <td class="paramname"><em>ciphersuite_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5965ab35a26a158ea971c8f87a7f1db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5965ab35a26a158ea971c8f87a7f1db">&#9670;&nbsp;</a></span>mbedtls_ssl_reset_checksum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_reset_checksum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/df9/ssl__tls_8c_ad5965ab35a26a158ea971c8f87a7f1db_cgraph.png" border="0" usemap="#ad4/df9/ssl__tls_8c_ad5965ab35a26a158ea971c8f87a7f1db_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a499c99645f5a59656b3b0724a586b31d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a499c99645f5a59656b3b0724a586b31d">&#9670;&nbsp;</a></span>mbedtls_ssl_handshake_wrapup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_handshake_wrapup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/df9/ssl__tls_8c_a499c99645f5a59656b3b0724a586b31d_cgraph.png" border="0" usemap="#ad4/df9/ssl__tls_8c_a499c99645f5a59656b3b0724a586b31d_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a42ec0d34dc6670ef0355c88489fd8e59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42ec0d34dc6670ef0355c88489fd8e59">&#9670;&nbsp;</a></span>mbedtls_ssl_write_finished()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_write_finished </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a081a893301f22c2db38c15ef2697ac48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a081a893301f22c2db38c15ef2697ac48">&#9670;&nbsp;</a></span>mbedtls_ssl_parse_finished()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_parse_finished </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/df9/ssl__tls_8c_a081a893301f22c2db38c15ef2697ac48_cgraph.png" border="0" usemap="#ad4/df9/ssl__tls_8c_a081a893301f22c2db38c15ef2697ac48_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a7980469655c1cdb8fd7e966bffe1fd02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7980469655c1cdb8fd7e966bffe1fd02">&#9670;&nbsp;</a></span>mbedtls_ssl_session_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_session_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/def/structmbedtls__ssl__session.html">mbedtls_ssl_session</a> *&#160;</td>
          <td class="paramname"><em>session</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize SSL session structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>SSL session </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8560dea66d7830a11874188727ec4c45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8560dea66d7830a11874188727ec4c45">&#9670;&nbsp;</a></span>mbedtls_ssl_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize an SSL context Just makes the context ready for <a class="el" href="../../df/d6d/ssl_8h.html#af79cb539a0ee6ac20cf9c574f4c3b343" title="Set up an SSL context for use.">mbedtls_ssl_setup()</a> or <a class="el" href="../../df/d6d/ssl_8h.html#a2dc104a181bcd11eafbbf7e6923978bc" title="Free referenced items in an SSL context and clear memory.">mbedtls_ssl_free()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>SSL context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af79cb539a0ee6ac20cf9c574f4c3b343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af79cb539a0ee6ac20cf9c574f4c3b343">&#9670;&nbsp;</a></span>mbedtls_ssl_setup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_setup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set up an SSL context for use. </p>
<dl class="section note"><dt>Note</dt><dd>No copy of the configuration context is made, it can be shared by many <a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> structures.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The conf structure will be accessed during the session. It must not be modified or freed as long as the session is active.</dd>
<dd>
This function must be called exactly once per context. Calling mbedtls_ssl_setup again is not supported, even if no session is active.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>SSL context </td></tr>
    <tr><td class="paramname">conf</td><td>SSL configuration to use</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or MBEDTLS_ERR_SSL_ALLOC_FAILED if memory allocation failed </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/df9/ssl__tls_8c_af79cb539a0ee6ac20cf9c574f4c3b343_cgraph.png" border="0" usemap="#ad4/df9/ssl__tls_8c_af79cb539a0ee6ac20cf9c574f4c3b343_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a21432367cbce428f10dcb62d9456fa7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21432367cbce428f10dcb62d9456fa7e">&#9670;&nbsp;</a></span>mbedtls_ssl_session_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_session_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset an already initialized SSL context for re-use while retaining application-set variables, function pointers and data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>SSL context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or MBEDTLS_ERR_SSL_ALLOC_FAILED, MBEDTLS_ERR_SSL_HW_ACCEL_FAILED or MBEDTLS_ERR_SSL_COMPRESSION_FAILED </dd></dl>

</div>
</div>
<a id="a3a763e35d55c18e6792a3b756d825684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a763e35d55c18e6792a3b756d825684">&#9670;&nbsp;</a></span>mbedtls_ssl_conf_endpoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_conf_endpoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>endpoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the current endpoint type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration </td></tr>
    <tr><td class="paramname">endpoint</td><td>must be MBEDTLS_SSL_IS_CLIENT or MBEDTLS_SSL_IS_SERVER </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2eb03afe9b2ca0f144a1c307100dc0ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eb03afe9b2ca0f144a1c307100dc0ca">&#9670;&nbsp;</a></span>mbedtls_ssl_conf_transport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_conf_transport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>transport</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the transport type (TLS or DTLS). Default: TLS. </p>
<dl class="section note"><dt>Note</dt><dd>For DTLS, you must either provide a recv callback that doesn't block, or one that handles timeouts, see <code><a class="el" href="../../df/d6d/ssl_8h.html#a8b7442420aef7f1a76fa8c5336362f9e" title="Set the underlying BIO callbacks for write, read and read-with-timeout.">mbedtls_ssl_set_bio()</a></code>. You also need to provide timer callbacks with <code><a class="el" href="../../df/d6d/ssl_8h.html#a335ee78886daf7f8fb369fa925b3cca8" title="Set the timer callbacks (Mandatory for DTLS.)">mbedtls_ssl_set_timer_cb()</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration </td></tr>
    <tr><td class="paramname">transport</td><td>transport type: MBEDTLS_SSL_TRANSPORT_STREAM for TLS, MBEDTLS_SSL_TRANSPORT_DATAGRAM for DTLS. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46d919254eafef2ae642fb692c5e560a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46d919254eafef2ae642fb692c5e560a">&#9670;&nbsp;</a></span>mbedtls_ssl_conf_dtls_anti_replay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_conf_dtls_anti_replay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable anti-replay protection for DTLS. (DTLS only, no effect on TLS.) Default: enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration </td></tr>
    <tr><td class="paramname">mode</td><td>MBEDTLS_SSL_ANTI_REPLAY_ENABLED or MBEDTLS_SSL_ANTI_REPLAY_DISABLED.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Disabling this is a security risk unless the application protocol handles duplicated packets in a safe way. You should not disable this without careful consideration. However, if your application already detects duplicated packets and needs information about them to adjust its transmission strategy, then you'll want to disable this. </dd></dl>

</div>
</div>
<a id="a9baa37a4b839319d00d8b43c8d266719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9baa37a4b839319d00d8b43c8d266719">&#9670;&nbsp;</a></span>mbedtls_ssl_conf_dtls_badmac_limit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_conf_dtls_badmac_limit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a limit on the number of records with a bad MAC before terminating the connection. (DTLS only, no effect on TLS.) Default: 0 (disabled). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration </td></tr>
    <tr><td class="paramname">limit</td><td>Limit, or 0 to disable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the limit is N, then the connection is terminated when the Nth non-authentic record is seen.</dd>
<dd>
Records with an invalid header are not counted, only the ones going through the authentication-decryption phase.</dd>
<dd>
This is a security trade-off related to the fact that it's often relatively easy for an active attacker ot inject UDP datagrams. On one hand, setting a low limit here makes it easier for such an attacker to forcibly terminated a connection. On the other hand, a high limit or no limit might make us waste resources checking authentication on many bogus packets. </dd></dl>

</div>
</div>
<a id="a84238750762b8cf8a6ca25d08efcc1ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84238750762b8cf8a6ca25d08efcc1ab">&#9670;&nbsp;</a></span>mbedtls_ssl_set_datagram_packing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_set_datagram_packing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>allow_packing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allow or disallow packing of multiple handshake records within a single datagram. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>The SSL context to configure. </td></tr>
    <tr><td class="paramname">allow_packing</td><td>This determines whether datagram packing may be used or not. A value of <code>0</code> means that every record will be sent in a separate datagram; a value of <code>1</code> means that, if space permits, multiple handshake messages (including CCS) belonging to a single flight may be packed within a single datagram.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is enabled by default and should only be disabled for test purposes, or if datagram packing causes interoperability issues with peers that don't support it.</dd>
<dd>
Allowing datagram packing reduces the network load since there's less overhead if multiple messages share the same datagram. Also, it increases the handshake efficiency since messages belonging to a single datagram will not be reordered in transit, and so future message buffering or flight retransmission (if no buffering is used) as means to deal with reordering are needed less frequently.</dd>
<dd>
Application records are not affected by this option and are currently always sent in separate datagrams. </dd></dl>

</div>
</div>
<a id="a6625bc4e7ffd535900ef53259cc21651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6625bc4e7ffd535900ef53259cc21651">&#9670;&nbsp;</a></span>mbedtls_ssl_conf_handshake_timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_conf_handshake_timeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set retransmit timeout values for the DTLS handshake. (DTLS only, no effect on TLS.) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration </td></tr>
    <tr><td class="paramname">min</td><td>Initial timeout value in milliseconds. Default: 1000 (1 second). </td></tr>
    <tr><td class="paramname">max</td><td>Maximum timeout value in milliseconds. Default: 60000 (60 seconds).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Default values are from RFC 6347 section 4.2.4.1.</dd>
<dd>
The 'min' value should typically be slightly above the expected round-trip time to your peer, plus whatever time it takes for the peer to process the message. For example, if your RTT is about 600ms and you peer needs up to 1s to do the cryptographic operations in the handshake, then you should set 'min' slightly above 1600. Lower values of 'min' might cause spurious resends which waste network resources, while larger value of 'min' will increase overall latency on unreliable network links.</dd>
<dd>
The more unreliable your network connection is, the larger your max / min ratio needs to be in order to achieve reliable handshakes.</dd>
<dd>
Messages are retransmitted up to log2(ceil(max/min)) times. For example, if min = 1s and max = 5s, the retransmit plan goes: send ... 1s -&gt; resend ... 2s -&gt; resend ... 4s -&gt; resend ... 5s -&gt; give up and return a timeout error. </dd></dl>

</div>
</div>
<a id="a5695285c9dbfefec295012b566290f37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5695285c9dbfefec295012b566290f37">&#9670;&nbsp;</a></span>mbedtls_ssl_conf_authmode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_conf_authmode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>authmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the certificate verification mode Default: NONE on server, REQUIRED on client. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration </td></tr>
    <tr><td class="paramname">authmode</td><td>can be:</td></tr>
  </table>
  </dd>
</dl>
<p>MBEDTLS_SSL_VERIFY_NONE: peer certificate is not checked (default on server) (insecure on client)</p>
<p>MBEDTLS_SSL_VERIFY_OPTIONAL: peer certificate is checked, however the handshake continues even if verification failed; <a class="el" href="../../df/d6d/ssl_8h.html#a516064f1468d459159ef7cd6c496a026" title="Return the result of the certificate verification.">mbedtls_ssl_get_verify_result()</a> can be called after the handshake is complete.</p>
<p>MBEDTLS_SSL_VERIFY_REQUIRED: peer <em>must</em> present a valid certificate, handshake is aborted if verification failed. (default on client)</p>
<dl class="section note"><dt>Note</dt><dd>On client, MBEDTLS_SSL_VERIFY_REQUIRED is the recommended mode. With MBEDTLS_SSL_VERIFY_OPTIONAL, the user needs to call <a class="el" href="../../df/d6d/ssl_8h.html#a516064f1468d459159ef7cd6c496a026" title="Return the result of the certificate verification.">mbedtls_ssl_get_verify_result()</a> at the right time(s), which may not be obvious, while REQUIRED always perform the verification as soon as possible. For example, REQUIRED was protecting against the "triple handshake" attack even before it was found. </dd></dl>

</div>
</div>
<a id="afc2b6b55d7ccaf38d84a4fbf1655f426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc2b6b55d7ccaf38d84a4fbf1655f426">&#9670;&nbsp;</a></span>mbedtls_ssl_conf_verify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_conf_verify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(void *, <a class="el" href="../../d6/daa/structmbedtls__x509__crt.html">mbedtls_x509_crt</a> *, int, uint32_t *)&#160;</td>
          <td class="paramname"><em>f_vrfy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p_vrfy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the verification callback (Optional). </p>
<pre class="fragment">            If set, the verify callback is called for each
            certificate in the chain. For implementation
            information, please see \c mbedtls_x509_crt_verify()
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration </td></tr>
    <tr><td class="paramname">f_vrfy</td><td>verification function </td></tr>
    <tr><td class="paramname">p_vrfy</td><td>verification parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a469cd1c64bbba4be22347bf8874a017e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a469cd1c64bbba4be22347bf8874a017e">&#9670;&nbsp;</a></span>mbedtls_ssl_conf_rng()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_conf_rng </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(void *, unsigned char *, size_t)&#160;</td>
          <td class="paramname"><em>f_rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p_rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the random number generator callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration </td></tr>
    <tr><td class="paramname">f_rng</td><td>RNG function </td></tr>
    <tr><td class="paramname">p_rng</td><td>RNG parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab15dcbe7c7fe2a5c118e7c486c07c921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab15dcbe7c7fe2a5c118e7c486c07c921">&#9670;&nbsp;</a></span>mbedtls_ssl_conf_dbg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_conf_dbg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *, int, const char *, int, const char *)&#160;</td>
          <td class="paramname"><em>f_dbg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p_dbg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the debug callback. </p>
<pre class="fragment">            The callback has the following argument:
            void *           opaque context for the callback
            int              debug level
            const char *     file name
            int              line number
            const char *     message
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration </td></tr>
    <tr><td class="paramname">f_dbg</td><td>debug function </td></tr>
    <tr><td class="paramname">p_dbg</td><td>debug parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b7442420aef7f1a76fa8c5336362f9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b7442420aef7f1a76fa8c5336362f9e">&#9670;&nbsp;</a></span>mbedtls_ssl_set_bio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_set_bio </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p_bio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/d6d/ssl_8h.html#a38e2b400d361f42f85833cdc30b3916e">mbedtls_ssl_send_t</a> *&#160;</td>
          <td class="paramname"><em>f_send</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/d6d/ssl_8h.html#ac06b19b96b643090c55f19b6c28b10c4">mbedtls_ssl_recv_t</a> *&#160;</td>
          <td class="paramname"><em>f_recv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/d6d/ssl_8h.html#a6d615ca95c8a67d7c5f9d7d256dc09e6">mbedtls_ssl_recv_timeout_t</a> *&#160;</td>
          <td class="paramname"><em>f_recv_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the underlying BIO callbacks for write, read and read-with-timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>SSL context </td></tr>
    <tr><td class="paramname">p_bio</td><td>parameter (context) shared by BIO callbacks </td></tr>
    <tr><td class="paramname">f_send</td><td>write callback </td></tr>
    <tr><td class="paramname">f_recv</td><td>read callback </td></tr>
    <tr><td class="paramname">f_recv_timeout</td><td>blocking read callback with timeout.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>One of f_recv or f_recv_timeout can be NULL, in which case the other is used. If both are non-NULL, f_recv_timeout is used and f_recv is ignored (as if it were NULL).</dd>
<dd>
The two most common use cases are:<ul>
<li>non-blocking I/O, f_recv != NULL, f_recv_timeout == NULL</li>
<li>blocking I/O, f_recv == NULL, f_recv_timout != NULL</li>
</ul>
</dd>
<dd>
For DTLS, you need to provide either a non-NULL f_recv_timeout callback, or a f_recv that doesn't block.</dd>
<dd>
See the documentations of <code>mbedtls_ssl_sent_t</code>, <code>mbedtls_ssl_recv_t</code> and <code>mbedtls_ssl_recv_timeout_t</code> for the conventions those callbacks must follow.</dd>
<dd>
On some platforms, <a class="el" href="../../d3/d0c/net__sockets_8c.html">net_sockets.c</a> provides <code><a class="el" href="../../d3/d0c/net__sockets_8c.html#a4841afd0e14f1fd44b82c3a850961ab7" title="Write at most &#39;len&#39; characters. If no error occurs, the actual amount read is returned.">mbedtls_net_send()</a></code>, <code><a class="el" href="../../d3/d0c/net__sockets_8c.html#a03af351ec420bbeb5e91357abcfb3663" title="Read at most &#39;len&#39; characters. If no error occurs, the actual amount read is returned.">mbedtls_net_recv()</a></code> and <code><a class="el" href="../../d3/d0c/net__sockets_8c.html#a67810154d2328a80b146155d8cdecfd9" title="Read at most &#39;len&#39; characters, blocking for at most &#39;timeout&#39; seconds. If no error occurs,...">mbedtls_net_recv_timeout()</a></code> that are suitable to be used here. </dd></dl>

</div>
</div>
<a id="a14ea71eb9f064d28fb5c393acc1e6975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ea71eb9f064d28fb5c393acc1e6975">&#9670;&nbsp;</a></span>mbedtls_ssl_set_mtu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_set_mtu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>mtu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the Maximum Tranport Unit (MTU). Special value: 0 means unset (no limit). This represents the maximum size of a datagram payload handled by the transport layer (usually UDP) as determined by the network link and stack. In practice, this controls the maximum size datagram the DTLS layer will pass to the <code>f_send()</code> callback set using <code><a class="el" href="../../df/d6d/ssl_8h.html#a8b7442420aef7f1a76fa8c5336362f9e" title="Set the underlying BIO callbacks for write, read and read-with-timeout.">mbedtls_ssl_set_bio()</a></code>. </p>
<dl class="section note"><dt>Note</dt><dd>The limit on datagram size is converted to a limit on record payload by subtracting the current overhead of encapsulation and encryption/authentication if any.</dd>
<dd>
This can be called at any point during the connection, for example when a Path Maximum Transfer Unit (PMTU) estimate becomes available from other sources, such as lower (or higher) protocol layers.</dd>
<dd>
This setting only controls the size of the packets we send, and does not restrict the size of the datagrams we're willing to receive. Client-side, you can request the server to use smaller records with <code><a class="el" href="../../df/d6d/ssl_8h.html#ac68fda83c26b3078e80f4dfc3b09bb94" title="Set the maximum fragment length to emit and/or negotiate (Default: the smaller of MBEDTLS_SSL_IN_CONT...">mbedtls_ssl_conf_max_frag_len()</a></code>.</dd>
<dd>
If both a MTU and a maximum fragment length have been configured (or negotiated with the peer), the resulting lower limit on record payload (see first note) is used.</dd>
<dd>
This can only be used to decrease the maximum size of datagrams (hence records, see first note) sent. It cannot be used to increase the maximum size of records over the limit set by #MBEDTLS_SSL_OUT_CONTENT_LEN.</dd>
<dd>
Values lower than the current record layer expansion will result in an error when trying to send data.</dd>
<dd>
Using record compression together with a non-zero MTU value will result in an error when trying to send data.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>SSL context </td></tr>
    <tr><td class="paramname">mtu</td><td>Value of the path MTU in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d925033b3a46a48b3f8acc1d743af90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d925033b3a46a48b3f8acc1d743af90">&#9670;&nbsp;</a></span>mbedtls_ssl_conf_read_timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_conf_read_timeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the timeout period for <a class="el" href="../../df/d6d/ssl_8h.html#aa2c29eeb1deaf5ad9f01a7515006ede5" title="Read at most &#39;len&#39; application data bytes.">mbedtls_ssl_read()</a> (Default: no timeout.) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration context </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout value in milliseconds. Use 0 for no timeout (default).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>With blocking I/O, this will only work if a non-NULL <code>f_recv_timeout</code> was set with <code><a class="el" href="../../df/d6d/ssl_8h.html#a8b7442420aef7f1a76fa8c5336362f9e" title="Set the underlying BIO callbacks for write, read and read-with-timeout.">mbedtls_ssl_set_bio()</a></code>. With non-blocking I/O, this will only work if timer callbacks were set with <code><a class="el" href="../../df/d6d/ssl_8h.html#a335ee78886daf7f8fb369fa925b3cca8" title="Set the timer callbacks (Mandatory for DTLS.)">mbedtls_ssl_set_timer_cb()</a></code>.</dd>
<dd>
With non-blocking I/O, you may also skip this function altogether and handle timeouts at the application layer. </dd></dl>

</div>
</div>
<a id="a335ee78886daf7f8fb369fa925b3cca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a335ee78886daf7f8fb369fa925b3cca8">&#9670;&nbsp;</a></span>mbedtls_ssl_set_timer_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_set_timer_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p_timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/d6d/ssl_8h.html#a61c5d9ed63c50ee809eec98820d3f36c">mbedtls_ssl_set_timer_t</a> *&#160;</td>
          <td class="paramname"><em>f_set_timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/d6d/ssl_8h.html#adea005600b532d788c05e9d01b42895b">mbedtls_ssl_get_timer_t</a> *&#160;</td>
          <td class="paramname"><em>f_get_timer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the timer callbacks (Mandatory for DTLS.) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>SSL context </td></tr>
    <tr><td class="paramname">p_timer</td><td>parameter (context) shared by timer callbacks </td></tr>
    <tr><td class="paramname">f_set_timer</td><td>set timer callback </td></tr>
    <tr><td class="paramname">f_get_timer</td><td>get timer callback. Must return:</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>See the documentation of <code>mbedtls_ssl_set_timer_t</code> and <code>mbedtls_ssl_get_timer_t</code> for the conventions this pair of callbacks must follow.</dd>
<dd>
On some platforms, <a class="el" href="../../d3/d62/timing_8c.html">timing.c</a> provides <code><a class="el" href="../../d3/d62/timing_8c.html#aeb3497ab85adabf7db89d81c34e2ef92" title="Set a pair of delays to watch (See mbedtls_timing_get_delay().)">mbedtls_timing_set_delay()</a></code> and <code><a class="el" href="../../d3/d62/timing_8c.html#afb1705e8c4227b0ec03089aa7fc54d9b" title="Get the status of delays (Memory helper: number of delays passed.)">mbedtls_timing_get_delay()</a></code> that are suitable for using here, except if using an event-driven style.</dd>
<dd>
See also the "DTLS tutorial" article in our knowledge base. <a href="https://tls.mbed.org/kb/how-to/dtls-tutorial">https://tls.mbed.org/kb/how-to/dtls-tutorial</a> </dd></dl>

</div>
</div>
<a id="a9a69464288d80b3904bc7540bd52aab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a69464288d80b3904bc7540bd52aab0">&#9670;&nbsp;</a></span>mbedtls_ssl_conf_session_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_conf_session_cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p_cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(void *, <a class="el" href="../../da/def/structmbedtls__ssl__session.html">mbedtls_ssl_session</a> *)&#160;</td>
          <td class="paramname"><em>f_get_cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(void *, const <a class="el" href="../../da/def/structmbedtls__ssl__session.html">mbedtls_ssl_session</a> *)&#160;</td>
          <td class="paramname"><em>f_set_cache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the session cache callbacks (server-side only) If not set, no session resuming is done (except if session tickets are enabled too). </p>
<p>The session cache has the responsibility to check for stale entries based on timeout. See RFC 5246 for recommendations.</p>
<p>Warning: session.peer_cert is cleared by the SSL/TLS layer on connection shutdown, so do not cache the pointer! Either set it to NULL or make a full copy of the certificate.</p>
<p>The get callback is called once during the initial handshake to enable session resuming. The get function has the following parameters: (void *parameter, <a class="el" href="../../da/def/structmbedtls__ssl__session.html">mbedtls_ssl_session</a> *session) If a valid entry is found, it should fill the master of the session object with the cached values and return 0, return 1 otherwise. Optionally peer_cert can be set as well if it is properly present in cache entry.</p>
<p>The set callback is called once during the initial handshake to enable session resuming after the entire handshake has been finished. The set function has the following parameters: (void *parameter, const <a class="el" href="../../da/def/structmbedtls__ssl__session.html">mbedtls_ssl_session</a> *session). The function should create a cache entry for future retrieval based on the data in the session structure and should keep in mind that the <a class="el" href="../../da/def/structmbedtls__ssl__session.html">mbedtls_ssl_session</a> object presented (and all its referenced data) is cleared by the SSL/TLS layer when the connection is terminated. It is recommended to add metadata to determine if an entry is still valid in the future. Return 0 if successfully cached, return 1 otherwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration </td></tr>
    <tr><td class="paramname">p_cache</td><td>parmater (context) for both callbacks </td></tr>
    <tr><td class="paramname">f_get_cache</td><td>session get callback </td></tr>
    <tr><td class="paramname">f_set_cache</td><td>session set callback </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91be5c606b9f7c1e44b3e507a4fe7b66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91be5c606b9f7c1e44b3e507a4fe7b66">&#9670;&nbsp;</a></span>mbedtls_ssl_set_session()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_set_session </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/def/structmbedtls__ssl__session.html">mbedtls_ssl_session</a> *&#160;</td>
          <td class="paramname"><em>session</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request resumption of session (client-side only) Session data is copied from presented session structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>SSL context </td></tr>
    <tr><td class="paramname">session</td><td>session context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, MBEDTLS_ERR_SSL_ALLOC_FAILED if memory allocation failed, MBEDTLS_ERR_SSL_BAD_INPUT_DATA if used server-side or arguments are otherwise invalid</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../df/d6d/ssl_8h.html#ad617a178adfaf259db89c4fe092ad6e1" title="Save session in order to resume it later (client-side only) Session data is copied to presented sessi...">mbedtls_ssl_get_session()</a> </dd></dl>

</div>
</div>
<a id="ac8e4df37cadda8f743ed45501a51fec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e4df37cadda8f743ed45501a51fec1">&#9670;&nbsp;</a></span>mbedtls_ssl_conf_ciphersuites()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_conf_ciphersuites </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>ciphersuites</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the list of allowed ciphersuites and the preference order. First in the list has the highest preference. (Overrides all version-specific lists) </p>
<p>The ciphersuites array is not copied, and must remain valid for the lifetime of the ssl_config.</p>
<p>Note: The server uses its own preferences over the preference of the client unless MBEDTLS_SSL_SRV_RESPECT_CLIENT_PREFERENCE is defined!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration </td></tr>
    <tr><td class="paramname">ciphersuites</td><td>0-terminated list of allowed ciphersuites </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa597f5461c48ee6014397c926916e6ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa597f5461c48ee6014397c926916e6ae">&#9670;&nbsp;</a></span>mbedtls_ssl_conf_ciphersuites_for_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_conf_ciphersuites_for_version </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>ciphersuites</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>major</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the list of allowed ciphersuites and the preference order for a specific version of the protocol. (Only useful on the server side) </p>
<p>The ciphersuites array is not copied, and must remain valid for the lifetime of the ssl_config.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration </td></tr>
    <tr><td class="paramname">ciphersuites</td><td>0-terminated list of allowed ciphersuites </td></tr>
    <tr><td class="paramname">major</td><td>Major version number (only MBEDTLS_SSL_MAJOR_VERSION_3 supported) </td></tr>
    <tr><td class="paramname">minor</td><td>Minor version number (MBEDTLS_SSL_MINOR_VERSION_0, MBEDTLS_SSL_MINOR_VERSION_1 and MBEDTLS_SSL_MINOR_VERSION_2, MBEDTLS_SSL_MINOR_VERSION_3 supported)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>With DTLS, use MBEDTLS_SSL_MINOR_VERSION_2 for DTLS 1.0 and MBEDTLS_SSL_MINOR_VERSION_3 for DTLS 1.2 </dd></dl>

</div>
</div>
<a id="a76dc3c312ffd51f6d0ca127b322307bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76dc3c312ffd51f6d0ca127b322307bb">&#9670;&nbsp;</a></span>mbedtls_ssl_conf_cert_profile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_conf_cert_profile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d8/d1b/structmbedtls__x509__crt__profile.html">mbedtls_x509_crt_profile</a> *&#160;</td>
          <td class="paramname"><em>profile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the X.509 security profile used for verification. </p>
<dl class="section note"><dt>Note</dt><dd>The restrictions are enforced for all certificates in the chain. However, signatures in the handshake are not covered by this setting but by <b><a class="el" href="../../df/d6d/ssl_8h.html#a73725fed867e0fd29396c7c6565a76e6" title="Set the allowed hashes for signatures during the handshake. (Default: all available hashes except MD5...">mbedtls_ssl_conf_sig_hashes()</a></b>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration </td></tr>
    <tr><td class="paramname">profile</td><td>Profile to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e54e9ace21beb608bae36ddb81a4fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e54e9ace21beb608bae36ddb81a4fb0">&#9670;&nbsp;</a></span>mbedtls_ssl_conf_own_cert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_conf_own_cert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/daa/structmbedtls__x509__crt.html">mbedtls_x509_crt</a> *&#160;</td>
          <td class="paramname"><em>own_cert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d1b/structmbedtls__pk__context.html">mbedtls_pk_context</a> *&#160;</td>
          <td class="paramname"><em>pk_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set own certificate chain and private key. </p>
<dl class="section note"><dt>Note</dt><dd>own_cert should contain in order from the bottom up your certificate chain. The top certificate (self-signed) can be omitted.</dd>
<dd>
On server, this function can be called multiple times to provision more than one cert/key pair (eg one ECDSA, one RSA with SHA-256, one RSA with SHA-1). An adequate certificate will be selected according to the client's advertised capabilities. In case mutliple certificates are adequate, preference is given to the one set by the first call to this function, then second, etc.</dd>
<dd>
On client, only the first call has any effect. That is, only one client certificate can be provisioned. The server's preferences in its CertficateRequest message will be ignored and our only cert will be sent regardless of whether it matches those preferences - the server can then decide what it wants to do with it.</dd>
<dd>
The provided <code>pk_key</code> needs to match the public key in the first certificate in <code>own_cert</code>, or all handshakes using that certificate will fail. It is your responsibility to ensure that; this function will not perform any check. You may use <a class="el" href="../../db/dbd/pk_8c.html#a87f9989d6859e2dceb5e1d4c4491fdca" title="Check if a public-private pair of keys matches.">mbedtls_pk_check_pair()</a> in order to perform this check yourself, but be aware that this function can be computationally expensive on some key types.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration </td></tr>
    <tr><td class="paramname">own_cert</td><td>own public certificate chain </td></tr>
    <tr><td class="paramname">pk_key</td><td>own private key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or MBEDTLS_ERR_SSL_ALLOC_FAILED </dd></dl>

</div>
</div>
<a id="a85c3bb6b682ba361d13de1c0a1eb69fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85c3bb6b682ba361d13de1c0a1eb69fb">&#9670;&nbsp;</a></span>mbedtls_ssl_conf_ca_chain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_conf_ca_chain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/daa/structmbedtls__x509__crt.html">mbedtls_x509_crt</a> *&#160;</td>
          <td class="paramname"><em>ca_chain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/d39/structmbedtls__x509__crl.html">mbedtls_x509_crl</a> *&#160;</td>
          <td class="paramname"><em>ca_crl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the data required to verify peer certificate. </p>
<dl class="section note"><dt>Note</dt><dd>See <code><a class="el" href="../../da/dc4/group__x509__module.html#ga98ed4504e4f832b735a230acf54fcde3" title="Verify the certificate signature.">mbedtls_x509_crt_verify()</a></code> for notes regarding the parameters ca_chain (maps to trust_ca for that function) and ca_crl.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration </td></tr>
    <tr><td class="paramname">ca_chain</td><td>trusted CA chain (meaning all fully trusted top-level CAs) </td></tr>
    <tr><td class="paramname">ca_crl</td><td>trusted CA CRLs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0353666974b1cd19dafb2c2b165d2f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0353666974b1cd19dafb2c2b165d2f2">&#9670;&nbsp;</a></span>mbedtls_ssl_set_hs_own_cert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_set_hs_own_cert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/daa/structmbedtls__x509__crt.html">mbedtls_x509_crt</a> *&#160;</td>
          <td class="paramname"><em>own_cert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d1b/structmbedtls__pk__context.html">mbedtls_pk_context</a> *&#160;</td>
          <td class="paramname"><em>pk_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set own certificate and key for the current handshake. </p>
<dl class="section note"><dt>Note</dt><dd>Same as <code><a class="el" href="../../df/d6d/ssl_8h.html#a4e54e9ace21beb608bae36ddb81a4fb0" title="Set own certificate chain and private key.">mbedtls_ssl_conf_own_cert()</a></code> but for use within the SNI callback.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>SSL context </td></tr>
    <tr><td class="paramname">own_cert</td><td>own public certificate chain </td></tr>
    <tr><td class="paramname">pk_key</td><td>own private key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or MBEDTLS_ERR_SSL_ALLOC_FAILED </dd></dl>

</div>
</div>
<a id="a33a781dcdc16bd649ea0346a598e9656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a781dcdc16bd649ea0346a598e9656">&#9670;&nbsp;</a></span>mbedtls_ssl_set_hs_ca_chain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_set_hs_ca_chain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/daa/structmbedtls__x509__crt.html">mbedtls_x509_crt</a> *&#160;</td>
          <td class="paramname"><em>ca_chain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/d39/structmbedtls__x509__crl.html">mbedtls_x509_crl</a> *&#160;</td>
          <td class="paramname"><em>ca_crl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the data required to verify peer certificate for the current handshake. </p>
<dl class="section note"><dt>Note</dt><dd>Same as <code><a class="el" href="../../df/d6d/ssl_8h.html#a85c3bb6b682ba361d13de1c0a1eb69fb" title="Set the data required to verify peer certificate.">mbedtls_ssl_conf_ca_chain()</a></code> but for use within the SNI callback.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>SSL context </td></tr>
    <tr><td class="paramname">ca_chain</td><td>trusted CA chain (meaning all fully trusted top-level CAs) </td></tr>
    <tr><td class="paramname">ca_crl</td><td>trusted CA CRLs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8366b49e25054078b5be139c0ce560d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8366b49e25054078b5be139c0ce560d7">&#9670;&nbsp;</a></span>mbedtls_ssl_set_hs_authmode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_set_hs_authmode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>authmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set authmode for the current handshake. </p>
<dl class="section note"><dt>Note</dt><dd>Same as <code><a class="el" href="../../df/d6d/ssl_8h.html#a5695285c9dbfefec295012b566290f37" title="Set the certificate verification mode Default: NONE on server, REQUIRED on client.">mbedtls_ssl_conf_authmode()</a></code> but for use within the SNI callback.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>SSL context </td></tr>
    <tr><td class="paramname">authmode</td><td>MBEDTLS_SSL_VERIFY_NONE, MBEDTLS_SSL_VERIFY_OPTIONAL or MBEDTLS_SSL_VERIFY_REQUIRED </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36ec09a4ebfcc3676807a0c83985bf15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36ec09a4ebfcc3676807a0c83985bf15">&#9670;&nbsp;</a></span>mbedtls_ssl_set_hs_ecjpake_password()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_set_hs_ecjpake_password </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>pw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pw_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the EC J-PAKE password for current handshake. </p>
<dl class="section note"><dt>Note</dt><dd>An internal copy is made, and destroyed as soon as the handshake is completed, or when the SSL context is reset or freed.</dd>
<dd>
The SSL context needs to be already set up. The right place to call this function is between <code><a class="el" href="../../df/d6d/ssl_8h.html#af79cb539a0ee6ac20cf9c574f4c3b343" title="Set up an SSL context for use.">mbedtls_ssl_setup()</a></code> or <code>mbedtls_ssl_reset()</code> and <code><a class="el" href="../../df/d6d/ssl_8h.html#a4a37e497cd08c896870a42b1b618186e" title="Perform the SSL handshake.">mbedtls_ssl_handshake()</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>SSL context </td></tr>
    <tr><td class="paramname">pw</td><td>EC J-PAKE password (pre-shared secret) </td></tr>
    <tr><td class="paramname">pw_len</td><td>length of pw in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or a negative error code. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/df9/ssl__tls_8c_a36ec09a4ebfcc3676807a0c83985bf15_cgraph.png" border="0" usemap="#ad4/df9/ssl__tls_8c_a36ec09a4ebfcc3676807a0c83985bf15_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a1e185199e3ff613bdd1c8231a19e24fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e185199e3ff613bdd1c8231a19e24fc">&#9670;&nbsp;</a></span>mbedtls_ssl_conf_psk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_conf_psk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>psk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>psk_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>psk_identity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>psk_identity_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the Pre Shared Key (PSK) and the expected identity name. </p>
<dl class="section note"><dt>Note</dt><dd>This is mainly useful for clients. Servers will usually want to use <code><a class="el" href="../../df/d6d/ssl_8h.html#a1b804626a236e493316c58b048ab5937" title="Set the PSK callback (server-side only).">mbedtls_ssl_conf_psk_cb()</a></code> instead.</dd>
<dd>
Currently clients can only register one pre-shared key. In other words, the servers' identity hint is ignored. Support for setting multiple PSKs on clients and selecting one based on the identity hint is not a planned feature but feedback is welcomed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration </td></tr>
    <tr><td class="paramname">psk</td><td>pointer to the pre-shared key </td></tr>
    <tr><td class="paramname">psk_len</td><td>pre-shared key length </td></tr>
    <tr><td class="paramname">psk_identity</td><td>pointer to the pre-shared key identity </td></tr>
    <tr><td class="paramname">psk_identity_len</td><td>identity key length</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful or MBEDTLS_ERR_SSL_ALLOC_FAILED </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/df9/ssl__tls_8c_a1e185199e3ff613bdd1c8231a19e24fc_cgraph.png" border="0" usemap="#ad4/df9/ssl__tls_8c_a1e185199e3ff613bdd1c8231a19e24fc_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a50f8bb06a3ec75f6fec4ccc2c1aad151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50f8bb06a3ec75f6fec4ccc2c1aad151">&#9670;&nbsp;</a></span>mbedtls_ssl_set_hs_psk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_set_hs_psk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>psk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>psk_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the Pre Shared Key (PSK) for the current handshake. </p>
<dl class="section note"><dt>Note</dt><dd>This should only be called inside the PSK callback, ie the function passed to <code><a class="el" href="../../df/d6d/ssl_8h.html#a1b804626a236e493316c58b048ab5937" title="Set the PSK callback (server-side only).">mbedtls_ssl_conf_psk_cb()</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>SSL context </td></tr>
    <tr><td class="paramname">psk</td><td>pointer to the pre-shared key </td></tr>
    <tr><td class="paramname">psk_len</td><td>pre-shared key length</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful or MBEDTLS_ERR_SSL_ALLOC_FAILED </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/df9/ssl__tls_8c_a50f8bb06a3ec75f6fec4ccc2c1aad151_cgraph.png" border="0" usemap="#ad4/df9/ssl__tls_8c_a50f8bb06a3ec75f6fec4ccc2c1aad151_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a1b804626a236e493316c58b048ab5937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b804626a236e493316c58b048ab5937">&#9670;&nbsp;</a></span>mbedtls_ssl_conf_psk_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_conf_psk_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(void *, <a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *, const unsigned char *, size_t)&#160;</td>
          <td class="paramname"><em>f_psk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p_psk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the PSK callback (server-side only). </p>
<pre class="fragment">            If set, the PSK callback is called for each
            handshake where a PSK ciphersuite was negotiated.
            The caller provides the identity received and wants to
            receive the actual PSK data and length.

            The callback has the following parameters: (void *parameter,
            mbedtls_ssl_context *ssl, const unsigned char *psk_identity,
            size_t identity_len)
            If a valid PSK identity is found, the callback should use
            \c mbedtls_ssl_set_hs_psk() on the ssl context to set the
            correct PSK and return 0.
            Any other return value will result in a denied PSK identity.
</pre><dl class="section note"><dt>Note</dt><dd>If you set a PSK callback using this function, then you don't need to set a PSK key and identity using <code><a class="el" href="../../df/d6d/ssl_8h.html#a1e185199e3ff613bdd1c8231a19e24fc" title="Set the Pre Shared Key (PSK) and the expected identity name.">mbedtls_ssl_conf_psk()</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration </td></tr>
    <tr><td class="paramname">f_psk</td><td>PSK identity function </td></tr>
    <tr><td class="paramname">p_psk</td><td>PSK identity parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62445aeddae0780ea2247c455a3d965d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62445aeddae0780ea2247c455a3d965d">&#9670;&nbsp;</a></span>mbedtls_ssl_conf_dh_param()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_conf_dh_param </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dhm_P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dhm_G</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the Diffie-Hellman public P and G values, read as hexadecimal strings (server-side only) (Default values: MBEDTLS_DHM_RFC3526_MODP_2048_[PG]) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration </td></tr>
    <tr><td class="paramname">dhm_P</td><td>Diffie-Hellman-Merkle modulus </td></tr>
    <tr><td class="paramname">dhm_G</td><td>Diffie-Hellman-Merkle generator</td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000061">Deprecated:</a></b></dt><dd>Superseded by <code>mbedtls_ssl_conf_dh_param_bin</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/df9/ssl__tls_8c_a62445aeddae0780ea2247c455a3d965d_cgraph.png" border="0" usemap="#ad4/df9/ssl__tls_8c_a62445aeddae0780ea2247c455a3d965d_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a457078c76cf96c9696fd226c8efe0674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a457078c76cf96c9696fd226c8efe0674">&#9670;&nbsp;</a></span>mbedtls_ssl_conf_dh_param_bin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_conf_dh_param_bin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>dhm_P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>P_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>dhm_G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>G_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the Diffie-Hellman public P and G values from big-endian binary presentations. (Default values: MBEDTLS_DHM_RFC3526_MODP_2048_[PG]_BIN) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration </td></tr>
    <tr><td class="paramname">dhm_P</td><td>Diffie-Hellman-Merkle modulus in big-endian binary form </td></tr>
    <tr><td class="paramname">P_len</td><td>Length of DHM modulus </td></tr>
    <tr><td class="paramname">dhm_G</td><td>Diffie-Hellman-Merkle generator in big-endian binary form </td></tr>
    <tr><td class="paramname">G_len</td><td>Length of DHM generator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/df9/ssl__tls_8c_a457078c76cf96c9696fd226c8efe0674_cgraph.png" border="0" usemap="#ad4/df9/ssl__tls_8c_a457078c76cf96c9696fd226c8efe0674_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="aec6d67681da3a0d5cb259137af176d56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec6d67681da3a0d5cb259137af176d56">&#9670;&nbsp;</a></span>mbedtls_ssl_conf_dh_param_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_conf_dh_param_ctx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d97/structmbedtls__dhm__context.html">mbedtls_dhm_context</a> *&#160;</td>
          <td class="paramname"><em>dhm_ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the Diffie-Hellman public P and G values, read from existing context (server-side only) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration </td></tr>
    <tr><td class="paramname">dhm_ctx</td><td>Diffie-Hellman-Merkle context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/df9/ssl__tls_8c_aec6d67681da3a0d5cb259137af176d56_cgraph.png" border="0" usemap="#ad4/df9/ssl__tls_8c_aec6d67681da3a0d5cb259137af176d56_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a9dd56f07a798d344dba5bcf33376edfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dd56f07a798d344dba5bcf33376edfd">&#9670;&nbsp;</a></span>mbedtls_ssl_conf_dhm_min_bitlen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_conf_dhm_min_bitlen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>bitlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the minimum length for Diffie-Hellman parameters. (Client-side only.) (Default: 1024 bits.) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration </td></tr>
    <tr><td class="paramname">bitlen</td><td>Minimum bit length of the DHM prime </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73725fed867e0fd29396c7c6565a76e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73725fed867e0fd29396c7c6565a76e6">&#9670;&nbsp;</a></span>mbedtls_ssl_conf_sig_hashes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_conf_sig_hashes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>hashes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the allowed hashes for signatures during the handshake. (Default: all available hashes except MD5.) </p>
<dl class="section note"><dt>Note</dt><dd>This only affects which hashes are offered and can be used for signatures during the handshake. Hashes for message authentication and the TLS PRF are controlled by the ciphersuite, see <code><a class="el" href="../../df/d6d/ssl_8h.html#ac8e4df37cadda8f743ed45501a51fec1" title="Set the list of allowed ciphersuites and the preference order. First in the list has the highest pref...">mbedtls_ssl_conf_ciphersuites()</a></code>. Hashes used for certificate signature are controlled by the verification profile, see <code><a class="el" href="../../df/d6d/ssl_8h.html#a76dc3c312ffd51f6d0ca127b322307bb" title="Set the X.509 security profile used for verification.">mbedtls_ssl_conf_cert_profile()</a></code>.</dd>
<dd>
This list should be ordered by decreasing preference (preferred hash first).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration </td></tr>
    <tr><td class="paramname">hashes</td><td>Ordered list of allowed signature hashes, terminated by <code>MBEDTLS_MD_NONE</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a60aaca8d54408d349d110280f06653b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60aaca8d54408d349d110280f06653b9">&#9670;&nbsp;</a></span>mbedtls_ssl_conf_curves()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_conf_curves </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/df7/ecp_8h.html#af79e530ea8f8416480f805baa20b1a2d">mbedtls_ecp_group_id</a> *&#160;</td>
          <td class="paramname"><em>curves</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the allowed curves in order of preference. (Default: all defined curves.) </p>
<p>On server: this only affects selection of the ECDHE curve; the curves used for ECDH and ECDSA are determined by the list of available certificates instead.</p>
<p>On client: this affects the list of curves offered for any use. The server can override our preference order.</p>
<p>Both sides: limits the set of curves accepted for use in ECDHE and in the peer's end-entity certificate.</p>
<dl class="section note"><dt>Note</dt><dd>This has no influence on which curves are allowed inside the certificate chains, see <code><a class="el" href="../../df/d6d/ssl_8h.html#a76dc3c312ffd51f6d0ca127b322307bb" title="Set the X.509 security profile used for verification.">mbedtls_ssl_conf_cert_profile()</a></code> for that. For the end-entity certificate however, the key will be accepted only if it is allowed both by this list and by the cert profile.</dd>
<dd>
This list should be ordered by decreasing preference (preferred curve first).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration </td></tr>
    <tr><td class="paramname">curves</td><td>Ordered list of allowed curves, terminated by MBEDTLS_ECP_DP_NONE. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa659024cf89e20d6d2248c0626db7ef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa659024cf89e20d6d2248c0626db7ef2">&#9670;&nbsp;</a></span>mbedtls_ssl_set_hostname()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_set_hostname </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hostname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set or reset the hostname to check against the received server certificate. It sets the ServerName TLS extension, too, if that extension is enabled. (client-side only) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>SSL context </td></tr>
    <tr><td class="paramname">hostname</td><td>the server hostname, may be NULL to clear hostname</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Maximum hostname length MBEDTLS_SSL_MAX_HOST_NAME_LEN.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, MBEDTLS_ERR_SSL_ALLOC_FAILED on allocation failure, MBEDTLS_ERR_SSL_BAD_INPUT_DATA on too long input hostname.</dd></dl>
<p>Hostname set to the one provided on success (cleared when NULL). On allocation failure hostname is cleared. On too long input failure, old hostname is unchanged. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/df9/ssl__tls_8c_aa659024cf89e20d6d2248c0626db7ef2_cgraph.png" border="0" usemap="#ad4/df9/ssl__tls_8c_aa659024cf89e20d6d2248c0626db7ef2_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a38ee2c1e3f232444df5ba3952d7ded33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38ee2c1e3f232444df5ba3952d7ded33">&#9670;&nbsp;</a></span>mbedtls_ssl_conf_sni()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_conf_sni </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(void *, <a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *, const unsigned char *, size_t)&#160;</td>
          <td class="paramname"><em>f_sni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p_sni</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set server side ServerName TLS extension callback (optional, server-side only). </p>
<p>If set, the ServerName callback is called whenever the server receives a ServerName TLS extension from the client during a handshake. The ServerName callback has the following parameters: (void *parameter, <a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl, const unsigned char *hostname, size_t len). If a suitable certificate is found, the callback must set the certificate(s) and key(s) to use with <code><a class="el" href="../../df/d6d/ssl_8h.html#aa0353666974b1cd19dafb2c2b165d2f2" title="Set own certificate and key for the current handshake.">mbedtls_ssl_set_hs_own_cert()</a></code> (can be called repeatedly), and may optionally adjust the CA and associated CRL with <code><a class="el" href="../../df/d6d/ssl_8h.html#a33a781dcdc16bd649ea0346a598e9656" title="Set the data required to verify peer certificate for the current handshake.">mbedtls_ssl_set_hs_ca_chain()</a></code> as well as the client authentication mode with <code><a class="el" href="../../df/d6d/ssl_8h.html#a8366b49e25054078b5be139c0ce560d7" title="Set authmode for the current handshake.">mbedtls_ssl_set_hs_authmode()</a></code>, then must return 0. If no matching name is found, the callback must either set a default cert, or return non-zero to abort the handshake at this point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration </td></tr>
    <tr><td class="paramname">f_sni</td><td>verification function </td></tr>
    <tr><td class="paramname">p_sni</td><td>verification parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae21135dddd89b2ef273c13e140097f5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae21135dddd89b2ef273c13e140097f5a">&#9670;&nbsp;</a></span>mbedtls_ssl_conf_alpn_protocols()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_conf_alpn_protocols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>protos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the supported Application Layer Protocols. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration </td></tr>
    <tr><td class="paramname">protos</td><td>Pointer to a NULL-terminated list of supported protocols, in decreasing preference order. The pointer to the list is recorded by the library for later reference as required, so the lifetime of the table must be atleast as long as the lifetime of the SSL configuration structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or MBEDTLS_ERR_SSL_BAD_INPUT_DATA. </dd></dl>

</div>
</div>
<a id="ad1ab606db1a9307b4aacccdcd1d1a6ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1ab606db1a9307b4aacccdcd1d1a6ef">&#9670;&nbsp;</a></span>mbedtls_ssl_get_alpn_protocol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* mbedtls_ssl_get_alpn_protocol </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of the negotiated Application Layer Protocol. This function should be called after the handshake is completed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>SSL context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Protcol name, or NULL if no protocol was negotiated. </dd></dl>

</div>
</div>
<a id="afc1a81e3fcbea3045b41ce739a47f54e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc1a81e3fcbea3045b41ce739a47f54e">&#9670;&nbsp;</a></span>mbedtls_ssl_conf_max_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_conf_max_version </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>major</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the maximum supported version sent from the client side and/or accepted at the server side (Default: MBEDTLS_SSL_MAX_MAJOR_VERSION, MBEDTLS_SSL_MAX_MINOR_VERSION) </p>
<dl class="section note"><dt>Note</dt><dd>This ignores ciphersuites from higher versions.</dd>
<dd>
With DTLS, use MBEDTLS_SSL_MINOR_VERSION_2 for DTLS 1.0 and MBEDTLS_SSL_MINOR_VERSION_3 for DTLS 1.2</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration </td></tr>
    <tr><td class="paramname">major</td><td>Major version number (only MBEDTLS_SSL_MAJOR_VERSION_3 supported) </td></tr>
    <tr><td class="paramname">minor</td><td>Minor version number (MBEDTLS_SSL_MINOR_VERSION_0, MBEDTLS_SSL_MINOR_VERSION_1 and MBEDTLS_SSL_MINOR_VERSION_2, MBEDTLS_SSL_MINOR_VERSION_3 supported) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0eade5c83cc08001672061c5925caaaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eade5c83cc08001672061c5925caaaa">&#9670;&nbsp;</a></span>mbedtls_ssl_conf_min_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_conf_min_version </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>major</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the minimum accepted SSL/TLS protocol version (Default: TLS 1.0) </p>
<dl class="section note"><dt>Note</dt><dd>Input outside of the SSL_MAX_XXXXX_VERSION and SSL_MIN_XXXXX_VERSION range is ignored.</dd>
<dd>
MBEDTLS_SSL_MINOR_VERSION_0 (SSL v3) should be avoided.</dd>
<dd>
With DTLS, use MBEDTLS_SSL_MINOR_VERSION_2 for DTLS 1.0 and MBEDTLS_SSL_MINOR_VERSION_3 for DTLS 1.2</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration </td></tr>
    <tr><td class="paramname">major</td><td>Major version number (only MBEDTLS_SSL_MAJOR_VERSION_3 supported) </td></tr>
    <tr><td class="paramname">minor</td><td>Minor version number (MBEDTLS_SSL_MINOR_VERSION_0, MBEDTLS_SSL_MINOR_VERSION_1 and MBEDTLS_SSL_MINOR_VERSION_2, MBEDTLS_SSL_MINOR_VERSION_3 supported) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb5a878b9aabe137572a8c73a840c480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb5a878b9aabe137572a8c73a840c480">&#9670;&nbsp;</a></span>mbedtls_ssl_conf_fallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_conf_fallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>fallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the fallback flag (client-side only). (Default: MBEDTLS_SSL_IS_NOT_FALLBACK). </p>
<dl class="section note"><dt>Note</dt><dd>Set to MBEDTLS_SSL_IS_FALLBACK when preparing a fallback connection, that is a connection with max_version set to a lower value than the value you're willing to use. Such fallback connections are not recommended but are sometimes necessary to interoperate with buggy (version-intolerant) servers.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>You should NOT set this to MBEDTLS_SSL_IS_FALLBACK for non-fallback connections! This would appear to work for a while, then cause failures when the server is upgraded to support a newer TLS version.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration </td></tr>
    <tr><td class="paramname">fallback</td><td>MBEDTLS_SSL_IS_NOT_FALLBACK or MBEDTLS_SSL_IS_FALLBACK </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05492293c43910a64f746af8f71efb2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05492293c43910a64f746af8f71efb2f">&#9670;&nbsp;</a></span>mbedtls_ssl_conf_cert_req_ca_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_conf_cert_req_ca_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>cert_req_ca_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether to send a list of acceptable CAs in CertificateRequest messages. (Default: do send) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration </td></tr>
    <tr><td class="paramname">cert_req_ca_list</td><td>MBEDTLS_SSL_CERT_REQ_CA_LIST_ENABLED or MBEDTLS_SSL_CERT_REQ_CA_LIST_DISABLED </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa8a1d55630fec25f2247fc9958eaa53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa8a1d55630fec25f2247fc9958eaa53">&#9670;&nbsp;</a></span>mbedtls_ssl_conf_encrypt_then_mac()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_conf_encrypt_then_mac </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>etm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable Encrypt-then-MAC (Default: MBEDTLS_SSL_ETM_ENABLED) </p>
<dl class="section note"><dt>Note</dt><dd>This should always be enabled, it is a security improvement, and should not cause any interoperability issue (used only if the peer supports it too).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration </td></tr>
    <tr><td class="paramname">etm</td><td>MBEDTLS_SSL_ETM_ENABLED or MBEDTLS_SSL_ETM_DISABLED </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a133db91d4a1dd44d212ac57e386c23b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a133db91d4a1dd44d212ac57e386c23b3">&#9670;&nbsp;</a></span>mbedtls_ssl_conf_extended_master_secret()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_conf_extended_master_secret </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable Extended Master Secret negotiation. (Default: MBEDTLS_SSL_EXTENDED_MS_ENABLED) </p>
<dl class="section note"><dt>Note</dt><dd>This should always be enabled, it is a security fix to the protocol, and should not cause any interoperability issue (used only if the peer supports it too).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration </td></tr>
    <tr><td class="paramname">ems</td><td>MBEDTLS_SSL_EXTENDED_MS_ENABLED or MBEDTLS_SSL_EXTENDED_MS_DISABLED </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e904913a122bd7cb13260217e4cc868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e904913a122bd7cb13260217e4cc868">&#9670;&nbsp;</a></span>mbedtls_ssl_conf_arc4_support()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_conf_arc4_support </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>arc4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable or enable support for RC4 (Default: MBEDTLS_SSL_ARC4_DISABLED) </p>
<dl class="section warning"><dt>Warning</dt><dd>Use of RC4 in DTLS/TLS has been prohibited by RFC 7465 for security reasons. Use at your own risk.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is deprecated and will likely be removed in a future version of the library. RC4 is disabled by default at compile time and needs to be actively enabled for use with legacy systems.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration </td></tr>
    <tr><td class="paramname">arc4</td><td>MBEDTLS_SSL_ARC4_ENABLED or MBEDTLS_SSL_ARC4_DISABLED </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac68fda83c26b3078e80f4dfc3b09bb94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac68fda83c26b3078e80f4dfc3b09bb94">&#9670;&nbsp;</a></span>mbedtls_ssl_conf_max_frag_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_conf_max_frag_len </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>mfl_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the maximum fragment length to emit and/or negotiate (Default: the smaller of MBEDTLS_SSL_IN_CONTENT_LEN and MBEDTLS_SSL_OUT_CONTENT_LEN, usually 2^14 bytes) (Server: set maximum fragment length to emit, usually negotiated by the client during handshake (Client: set maximum fragment length to emit <em>and</em> negotiate with the server during handshake) </p>
<dl class="section note"><dt>Note</dt><dd>With TLS, this currently only affects ApplicationData (sent with <code><a class="el" href="../../df/d6d/ssl_8h.html#aa2c29eeb1deaf5ad9f01a7515006ede5" title="Read at most &#39;len&#39; application data bytes.">mbedtls_ssl_read()</a></code>), not handshake messages. With DTLS, this affects both ApplicationData and handshake.</dd>
<dd>
This sets the maximum length for a record's payload, excluding record overhead that will be added to it, see <code><a class="el" href="../../df/d6d/ssl_8h.html#a935f3ebfb31f988e24a8bf9bcb0fd26b" title="Return the (maximum) number of bytes added by the record layer: header + encryption/MAC overhead (inc...">mbedtls_ssl_get_record_expansion()</a></code>.</dd>
<dd>
For DTLS, it is also possible to set a limit for the total size of daragrams passed to the transport layer, including record overhead, see <code><a class="el" href="../../df/d6d/ssl_8h.html#a14ea71eb9f064d28fb5c393acc1e6975" title="Set the Maximum Tranport Unit (MTU). Special value: 0 means unset (no limit). This represents the max...">mbedtls_ssl_set_mtu()</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration </td></tr>
    <tr><td class="paramname">mfl_code</td><td>Code for maximum fragment length (allowed values: MBEDTLS_SSL_MAX_FRAG_LEN_512, MBEDTLS_SSL_MAX_FRAG_LEN_1024, MBEDTLS_SSL_MAX_FRAG_LEN_2048, MBEDTLS_SSL_MAX_FRAG_LEN_4096)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful or MBEDTLS_ERR_SSL_BAD_INPUT_DATA </dd></dl>

</div>
</div>
<a id="a739b67cfc0350ae4a2c9a2e99737bea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a739b67cfc0350ae4a2c9a2e99737bea7">&#9670;&nbsp;</a></span>mbedtls_ssl_conf_truncated_hmac()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_conf_truncated_hmac </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>truncate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Activate negotiation of truncated HMAC (Default: MBEDTLS_SSL_TRUNC_HMAC_DISABLED) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration </td></tr>
    <tr><td class="paramname">truncate</td><td>Enable or disable (MBEDTLS_SSL_TRUNC_HMAC_ENABLED or MBEDTLS_SSL_TRUNC_HMAC_DISABLED) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2cafaf0e79682a1152838d4991b59e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cafaf0e79682a1152838d4991b59e23">&#9670;&nbsp;</a></span>mbedtls_ssl_conf_cbc_record_splitting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_conf_cbc_record_splitting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>split</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable / Disable 1/n-1 record splitting (Default: MBEDTLS_SSL_CBC_RECORD_SPLITTING_ENABLED) </p>
<dl class="section note"><dt>Note</dt><dd>Only affects SSLv3 and TLS 1.0, not higher versions. Does not affect non-CBC ciphersuites in any version.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration </td></tr>
    <tr><td class="paramname">split</td><td>MBEDTLS_SSL_CBC_RECORD_SPLITTING_ENABLED or MBEDTLS_SSL_CBC_RECORD_SPLITTING_DISABLED </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a193c7bf368780f485e20170c807709e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a193c7bf368780f485e20170c807709e5">&#9670;&nbsp;</a></span>mbedtls_ssl_conf_legacy_renegotiation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_conf_legacy_renegotiation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>allow_legacy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prevent or allow legacy renegotiation. (Default: MBEDTLS_SSL_LEGACY_NO_RENEGOTIATION) </p>
<p>MBEDTLS_SSL_LEGACY_NO_RENEGOTIATION allows connections to be established even if the peer does not support secure renegotiation, but does not allow renegotiation to take place if not secure. (Interoperable and secure option)</p>
<p>MBEDTLS_SSL_LEGACY_ALLOW_RENEGOTIATION allows renegotiations with non-upgraded peers. Allowing legacy renegotiation makes the connection vulnerable to specific man in the middle attacks. (See RFC 5746) (Most interoperable and least secure option)</p>
<p>MBEDTLS_SSL_LEGACY_BREAK_HANDSHAKE breaks off connections if peer does not support secure renegotiation. Results in interoperability issues with non-upgraded peers that do not support renegotiation altogether. (Most secure option, interoperability issues)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration </td></tr>
    <tr><td class="paramname">allow_legacy</td><td>Prevent or allow (SSL_NO_LEGACY_RENEGOTIATION, SSL_ALLOW_LEGACY_RENEGOTIATION or MBEDTLS_SSL_LEGACY_BREAK_HANDSHAKE) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad4f50fc1c0a018fd5eb18fd9621d0d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad4f50fc1c0a018fd5eb18fd9621d0d3">&#9670;&nbsp;</a></span>mbedtls_ssl_conf_renegotiation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_conf_renegotiation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>renegotiation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable / Disable renegotiation support for connection when initiated by peer (Default: MBEDTLS_SSL_RENEGOTIATION_DISABLED) </p>
<dl class="section warning"><dt>Warning</dt><dd>It is recommended to always disable renegotation unless you know you need it and you know what you're doing. In the past, there have been several issues associated with renegotiation or a poor understanding of its properties.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Server-side, enabling renegotiation also makes the server susceptible to a resource DoS by a malicious client.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration </td></tr>
    <tr><td class="paramname">renegotiation</td><td>Enable or disable (MBEDTLS_SSL_RENEGOTIATION_ENABLED or MBEDTLS_SSL_RENEGOTIATION_DISABLED) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d193b15941a556baaf2cb94138d66df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d193b15941a556baaf2cb94138d66df">&#9670;&nbsp;</a></span>mbedtls_ssl_conf_renegotiation_enforced()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_conf_renegotiation_enforced </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_records</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enforce renegotiation requests. (Default: enforced, max_records = 16) </p>
<p>When we request a renegotiation, the peer can comply or ignore the request. This function allows us to decide whether to enforce our renegotiation requests by closing the connection if the peer doesn't comply.</p>
<p>However, records could already be in transit from the peer when the request is emitted. In order to increase reliability, we can accept a number of records before the expected handshake records.</p>
<p>The optimal value is highly dependent on the specific usage scenario.</p>
<dl class="section note"><dt>Note</dt><dd>With DTLS and server-initiated renegotiation, the HelloRequest is retransmited every time <a class="el" href="../../df/d6d/ssl_8h.html#aa2c29eeb1deaf5ad9f01a7515006ede5" title="Read at most &#39;len&#39; application data bytes.">mbedtls_ssl_read()</a> times out or receives Application Data, until:<ul>
<li>max_records records have beens seen, if it is &gt;= 0, or</li>
<li>the number of retransmits that would happen during an actual handshake has been reached. Please remember the request might be lost a few times if you consider setting max_records to a really low value.</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>On client, the grace period can only happen during <a class="el" href="../../df/d6d/ssl_8h.html#aa2c29eeb1deaf5ad9f01a7515006ede5" title="Read at most &#39;len&#39; application data bytes.">mbedtls_ssl_read()</a>, as opposed to <a class="el" href="../../df/d6d/ssl_8h.html#a5bbda87d484de82df730758b475f32e5" title="Try to write exactly &#39;len&#39; application data bytes.">mbedtls_ssl_write()</a> and <a class="el" href="../../df/d6d/ssl_8h.html#a49b7a27a616495d5f0a4fabc3f550dbb" title="Initiate an SSL renegotiation on the running connection. Client: perform the renegotiation right now....">mbedtls_ssl_renegotiate()</a> which always behave as if max_record was 0. The reason is, if we receive application data from the server, we need a place to write it, which only happens during <a class="el" href="../../df/d6d/ssl_8h.html#aa2c29eeb1deaf5ad9f01a7515006ede5" title="Read at most &#39;len&#39; application data bytes.">mbedtls_ssl_read()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration </td></tr>
    <tr><td class="paramname">max_records</td><td>Use MBEDTLS_SSL_RENEGOTIATION_NOT_ENFORCED if you don't want to enforce renegotiation, or a non-negative value to enforce it but allow for a grace period of max_records records. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1785faa0640bd6190c1c17a94b408e31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1785faa0640bd6190c1c17a94b408e31">&#9670;&nbsp;</a></span>mbedtls_ssl_conf_renegotiation_period()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_conf_renegotiation_period </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>period</em>[8]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set record counter threshold for periodic renegotiation. (Default: 2^48 - 1) </p>
<p>Renegotiation is automatically triggered when a record counter (outgoing or ingoing) crosses the defined threshold. The default value is meant to prevent the connection from being closed when the counter is about to reached its maximal value (it is not allowed to wrap).</p>
<p>Lower values can be used to enforce policies such as "keys
                must be refreshed every N packets with cipher X".</p>
<p>The renegotiation period can be disabled by setting conf-&gt;disable_renegotiation to MBEDTLS_SSL_RENEGOTIATION_DISABLED.</p>
<dl class="section note"><dt>Note</dt><dd>When the configured transport is MBEDTLS_SSL_TRANSPORT_DATAGRAM the maximum renegotiation period is 2^48 - 1, and for MBEDTLS_SSL_TRANSPORT_STREAM, the maximum renegotiation period is 2^64 - 1.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration </td></tr>
    <tr><td class="paramname">period</td><td>The threshold value: a big-endian 64-bit number. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97e547f900979337f4083a8158918fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97e547f900979337f4083a8158918fcc">&#9670;&nbsp;</a></span>mbedtls_ssl_conf_session_tickets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_conf_session_tickets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>use_tickets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable / Disable session tickets (client only). (Default: MBEDTLS_SSL_SESSION_TICKETS_ENABLED.) </p>
<dl class="section note"><dt>Note</dt><dd>On server, use <code><a class="el" href="../../df/d6d/ssl_8h.html#a73f028424df0b3a3b3360df0768df992" title="Configure SSL session ticket callbacks (server only). (Default: none.)">mbedtls_ssl_conf_session_tickets_cb()</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration </td></tr>
    <tr><td class="paramname">use_tickets</td><td>Enable or disable (MBEDTLS_SSL_SESSION_TICKETS_ENABLED or MBEDTLS_SSL_SESSION_TICKETS_DISABLED) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73f028424df0b3a3b3360df0768df992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73f028424df0b3a3b3360df0768df992">&#9670;&nbsp;</a></span>mbedtls_ssl_conf_session_tickets_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_conf_session_tickets_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/d6d/ssl_8h.html#a112d1fc2dd4db788592457d14c0c2899">mbedtls_ssl_ticket_write_t</a> *&#160;</td>
          <td class="paramname"><em>f_ticket_write</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/d6d/ssl_8h.html#a48aea353b22e86deece00933ef941536">mbedtls_ssl_ticket_parse_t</a> *&#160;</td>
          <td class="paramname"><em>f_ticket_parse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p_ticket</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure SSL session ticket callbacks (server only). (Default: none.) </p>
<dl class="section note"><dt>Note</dt><dd>On server, session tickets are enabled by providing non-NULL callbacks.</dd>
<dd>
On client, use <code><a class="el" href="../../df/d6d/ssl_8h.html#a97e547f900979337f4083a8158918fcc" title="Enable / Disable session tickets (client only). (Default: MBEDTLS_SSL_SESSION_TICKETS_ENABLED....">mbedtls_ssl_conf_session_tickets()</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration context </td></tr>
    <tr><td class="paramname">f_ticket_write</td><td>Callback for writing a ticket </td></tr>
    <tr><td class="paramname">f_ticket_parse</td><td>Callback for parsing a ticket </td></tr>
    <tr><td class="paramname">p_ticket</td><td>Context shared by the two callbacks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab31125a4db90d3313e17581cb5d6d634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab31125a4db90d3313e17581cb5d6d634">&#9670;&nbsp;</a></span>mbedtls_ssl_conf_export_keys_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_conf_export_keys_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/d6d/ssl_8h.html#a8f3ea9d32be68d7cd1605f39ce00d697">mbedtls_ssl_export_keys_t</a> *&#160;</td>
          <td class="paramname"><em>f_export_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p_export_keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure key export callback. (Default: none.) </p>
<dl class="section note"><dt>Note</dt><dd>See <code>mbedtls_ssl_export_keys_t</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration context </td></tr>
    <tr><td class="paramname">f_export_keys</td><td>Callback for exporting keys </td></tr>
    <tr><td class="paramname">p_export_keys</td><td>Context for the callback </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae84a75ff85f1bbb7d5e8c7807939fec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae84a75ff85f1bbb7d5e8c7807939fec6">&#9670;&nbsp;</a></span>mbedtls_ssl_conf_async_private_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_conf_async_private_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/d6d/ssl_8h.html#ad57308aa77db11dbc3551fd92deb2520">mbedtls_ssl_async_sign_t</a> *&#160;</td>
          <td class="paramname"><em>f_async_sign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/d6d/ssl_8h.html#ac18191035f2598e3311d24a3ae40a0fa">mbedtls_ssl_async_decrypt_t</a> *&#160;</td>
          <td class="paramname"><em>f_async_decrypt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/d6d/ssl_8h.html#a6a67de0c00f4aff4500ece33645a96cd">mbedtls_ssl_async_resume_t</a> *&#160;</td>
          <td class="paramname"><em>f_async_resume</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/d6d/ssl_8h.html#a084ed94ac531cfde7dcd0d0c05d392bd">mbedtls_ssl_async_cancel_t</a> *&#160;</td>
          <td class="paramname"><em>f_async_cancel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>config_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure asynchronous private key operation callbacks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration context </td></tr>
    <tr><td class="paramname">f_async_sign</td><td>Callback to start a signature operation. See the description of <a class="el" href="../../df/d6d/ssl_8h.html#ad57308aa77db11dbc3551fd92deb2520" title="Callback type: start external signature operation.">mbedtls_ssl_async_sign_t</a> for more information. This may be <code>NULL</code> if the external processor does not support any signature operation; in this case the private key object associated with the certificate will be used. </td></tr>
    <tr><td class="paramname">f_async_decrypt</td><td>Callback to start a decryption operation. See the description of <a class="el" href="../../df/d6d/ssl_8h.html#ac18191035f2598e3311d24a3ae40a0fa" title="Callback type: start external decryption operation.">mbedtls_ssl_async_decrypt_t</a> for more information. This may be <code>NULL</code> if the external processor does not support any decryption operation; in this case the private key object associated with the certificate will be used. </td></tr>
    <tr><td class="paramname">f_async_resume</td><td>Callback to resume an asynchronous operation. See the description of <a class="el" href="../../df/d6d/ssl_8h.html#a6a67de0c00f4aff4500ece33645a96cd" title="Callback type: resume external operation.">mbedtls_ssl_async_resume_t</a> for more information. This may not be <code>NULL</code> unless <code>f_async_sign</code> and <code>f_async_decrypt</code> are both <code>NULL</code>. </td></tr>
    <tr><td class="paramname">f_async_cancel</td><td>Callback to cancel an asynchronous operation. See the description of <a class="el" href="../../df/d6d/ssl_8h.html#a084ed94ac531cfde7dcd0d0c05d392bd" title="Callback type: cancel external operation.">mbedtls_ssl_async_cancel_t</a> for more information. This may be <code>NULL</code> if no cleanup is needed. </td></tr>
    <tr><td class="paramname">config_data</td><td>A pointer to configuration data which can be retrieved with <a class="el" href="../../df/d6d/ssl_8h.html#a374a41575f2f8a478bda3479772f943c" title="Retrieve the configuration data set by mbedtls_ssl_conf_async_private_cb().">mbedtls_ssl_conf_get_async_config_data()</a>. The library stores this value without dereferencing it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a374a41575f2f8a478bda3479772f943c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a374a41575f2f8a478bda3479772f943c">&#9670;&nbsp;</a></span>mbedtls_ssl_conf_get_async_config_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* mbedtls_ssl_conf_get_async_config_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the configuration data set by <a class="el" href="../../df/d6d/ssl_8h.html#a0675aed5a2b2b9ff219a62ed28b50819" title="Configure asynchronous private key operation callbacks.">mbedtls_ssl_conf_async_private_cb()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The configuration data set by <a class="el" href="../../df/d6d/ssl_8h.html#a0675aed5a2b2b9ff219a62ed28b50819" title="Configure asynchronous private key operation callbacks.">mbedtls_ssl_conf_async_private_cb()</a>. </dd></dl>

</div>
</div>
<a id="a7e424db2d8ccc9f0d5fe4ed0a9a5bab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e424db2d8ccc9f0d5fe4ed0a9a5bab2">&#9670;&nbsp;</a></span>mbedtls_ssl_get_async_operation_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* mbedtls_ssl_get_async_operation_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the asynchronous operation user context. </p>
<dl class="section note"><dt>Note</dt><dd>This function may only be called while a handshake is in progress.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>The SSL context to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The asynchronous operation user context that was last set during the current handshake. If <a class="el" href="../../df/d6d/ssl_8h.html#ac57fb2abf2a5cd821d0ec8c3d6c59daf" title="Retrieve the asynchronous operation user context.">mbedtls_ssl_set_async_operation_data()</a> has not yet been called during the current handshake, this function returns <code>NULL</code>. </dd></dl>

</div>
</div>
<a id="ac57fb2abf2a5cd821d0ec8c3d6c59daf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac57fb2abf2a5cd821d0ec8c3d6c59daf">&#9670;&nbsp;</a></span>mbedtls_ssl_set_async_operation_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_set_async_operation_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the asynchronous operation user context. </p>
<dl class="section note"><dt>Note</dt><dd>This function may only be called while a handshake is in progress.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>The SSL context to access. </td></tr>
    <tr><td class="paramname">ctx</td><td>The new value of the asynchronous operation user context. Call <a class="el" href="../../df/d6d/ssl_8h.html#a7e424db2d8ccc9f0d5fe4ed0a9a5bab2" title="Retrieve the asynchronous operation user context.">mbedtls_ssl_get_async_operation_data()</a> later during the same handshake to retrieve this value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad43142085f3182e9b0dc967ec582032b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43142085f3182e9b0dc967ec582032b">&#9670;&nbsp;</a></span>mbedtls_ssl_get_bytes_avail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mbedtls_ssl_get_bytes_avail </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of application data bytes remaining to be read from the current record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>SSL context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>How many bytes are available in the application data record read buffer.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>When working over a datagram transport, this is useful to detect the current datagram's boundary in case <code>mbedtls_ssl_read</code> has written the maximal amount of data fitting into the input buffer. </dd></dl>

</div>
</div>
<a id="a4075f7de9877fd667bcfa2e819e33426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4075f7de9877fd667bcfa2e819e33426">&#9670;&nbsp;</a></span>mbedtls_ssl_check_pending()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_check_pending </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if there is data already read from the underlying transport but not yet processed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>SSL context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if nothing's pending, 1 otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is different in purpose and behaviour from <code>mbedtls_ssl_get_bytes_avail</code> in that it considers any kind of unprocessed data, not only unread application data. If <code>mbedtls_ssl_get_bytes</code> returns a non-zero value, this function will also signal pending data, but the converse does not hold. For example, in DTLS there might be further records waiting to be processed from the current underlying transport's datagram.</dd>
<dd>
If this function returns 1 (data pending), this does not imply that a subsequent call to <code>mbedtls_ssl_read</code> will provide any data; e.g., the unprocessed data might turn out to be an alert or a handshake message.</dd>
<dd>
This function is useful in the following situation: If the SSL/TLS module successfully returns from an operation - e.g. a handshake or an application record read - and you're awaiting incoming data next, you must not immediately idle on the underlying transport to have data ready, but you need to check the value of this function first. The reason is that the desired data might already be read but not yet processed. If, in contrast, a previous call to the SSL/TLS module returned MBEDTLS_ERR_SSL_WANT_READ, it is not necessary to call this function, as the latter error code entails that all internal data has been processed. </dd></dl>

</div>
</div>
<a id="a516064f1468d459159ef7cd6c496a026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a516064f1468d459159ef7cd6c496a026">&#9670;&nbsp;</a></span>mbedtls_ssl_get_verify_result()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mbedtls_ssl_get_verify_result </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the result of the certificate verification. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>The SSL context to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0</code> if the certificate verification was successful. </dd>
<dd>
<code>-1u</code> if the result is not available. This may happen e.g. if the handshake aborts early, or a verification callback returned a fatal error. </dd>
<dd>
A bitwise combination of <code>MBEDTLS_X509_BADCERT_XXX</code> and <code>MBEDTLS_X509_BADCRL_XXX</code> failure flags; see <a class="el" href="../../d6/d90/x509_8h.html" title="X.509 generic defines and structures.">x509.h</a>. </dd></dl>

</div>
</div>
<a id="a18739598df499461369020b8ea6fff1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18739598df499461369020b8ea6fff1c">&#9670;&nbsp;</a></span>mbedtls_ssl_get_ciphersuite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* mbedtls_ssl_get_ciphersuite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the name of the current ciphersuite. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>SSL context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string containing the ciphersuite name </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/df9/ssl__tls_8c_a18739598df499461369020b8ea6fff1c_cgraph.png" border="0" usemap="#ad4/df9/ssl__tls_8c_a18739598df499461369020b8ea6fff1c_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a1ee2e52fe2ae9620af84df97a0347ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ee2e52fe2ae9620af84df97a0347ce3">&#9670;&nbsp;</a></span>mbedtls_ssl_get_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* mbedtls_ssl_get_version </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the current SSL version (SSLv3/TLSv1/etc) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>SSL context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string containing the SSL version </dd></dl>

</div>
</div>
<a id="a935f3ebfb31f988e24a8bf9bcb0fd26b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a935f3ebfb31f988e24a8bf9bcb0fd26b">&#9670;&nbsp;</a></span>mbedtls_ssl_get_record_expansion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_get_record_expansion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the (maximum) number of bytes added by the record layer: header + encryption/MAC overhead (inc. padding) </p>
<dl class="section note"><dt>Note</dt><dd>This function is not available (always returns an error) when record compression is enabled.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>SSL context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current maximum record expansion in bytes, or MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE if compression is enabled, which makes expansion much less predictable </dd></dl>

</div>
</div>
<a id="a44fb4dcf45412d667778432836be9150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44fb4dcf45412d667778432836be9150">&#9670;&nbsp;</a></span>mbedtls_ssl_get_max_frag_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mbedtls_ssl_get_max_frag_len </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the maximum fragment length (payload, in bytes). This is the value negotiated with peer if any, or the locally configured value. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../df/d6d/ssl_8h.html#ac68fda83c26b3078e80f4dfc3b09bb94" title="Set the maximum fragment length to emit and/or negotiate (Default: the smaller of MBEDTLS_SSL_IN_CONT...">mbedtls_ssl_conf_max_frag_len()</a> </dd>
<dd>
mbedtls_ssl_get_max_record_payload()</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>SSL context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current maximum fragment length. </dd></dl>

</div>
</div>
<a id="a58a7ddcf453791f2947bc7f99503047d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58a7ddcf453791f2947bc7f99503047d">&#9670;&nbsp;</a></span>mbedtls_ssl_get_max_out_record_payload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_get_max_out_record_payload </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the current maximum outgoing record payload in bytes. This takes into account the <a class="el" href="../../db/d16/config_8h.html" title="Configuration options (set of defines)">config.h</a> setting <code>MBEDTLS_SSL_OUT_CONTENT_LEN</code>, the configured and negotiated max fragment length extension if used, and for DTLS the path MTU as configured and current record expansion. </p>
<dl class="section note"><dt>Note</dt><dd>With DTLS, <code><a class="el" href="../../df/d6d/ssl_8h.html#a5bbda87d484de82df730758b475f32e5" title="Try to write exactly &#39;len&#39; application data bytes.">mbedtls_ssl_write()</a></code> will return an error if called with a larger length value. With TLS, <code><a class="el" href="../../df/d6d/ssl_8h.html#a5bbda87d484de82df730758b475f32e5" title="Try to write exactly &#39;len&#39; application data bytes.">mbedtls_ssl_write()</a></code> will fragment the input if necessary and return the number of bytes written; it is up to the caller to call <code><a class="el" href="../../df/d6d/ssl_8h.html#a5bbda87d484de82df730758b475f32e5" title="Try to write exactly &#39;len&#39; application data bytes.">mbedtls_ssl_write()</a></code> again in order to send the remaining bytes if any.</dd>
<dd>
This function is not available (always returns an error) when record compression is enabled.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../df/d6d/ssl_8h.html#a14ea71eb9f064d28fb5c393acc1e6975" title="Set the Maximum Tranport Unit (MTU). Special value: 0 means unset (no limit). This represents the max...">mbedtls_ssl_set_mtu()</a> </dd>
<dd>
<a class="el" href="../../df/d6d/ssl_8h.html#a44fb4dcf45412d667778432836be9150" title="Return the maximum fragment length (payload, in bytes). This is the value negotiated with peer if any...">mbedtls_ssl_get_max_frag_len()</a> </dd>
<dd>
<a class="el" href="../../df/d6d/ssl_8h.html#a935f3ebfb31f988e24a8bf9bcb0fd26b" title="Return the (maximum) number of bytes added by the record layer: header + encryption/MAC overhead (inc...">mbedtls_ssl_get_record_expansion()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>SSL context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current maximum payload for an outgoing record, or a negative error code. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/df9/ssl__tls_8c_a58a7ddcf453791f2947bc7f99503047d_cgraph.png" border="0" usemap="#ad4/df9/ssl__tls_8c_a58a7ddcf453791f2947bc7f99503047d_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="aa7ab0ac8d8341063a0f815ee99337831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7ab0ac8d8341063a0f815ee99337831">&#9670;&nbsp;</a></span>mbedtls_ssl_get_peer_cert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d6/daa/structmbedtls__x509__crt.html">mbedtls_x509_crt</a>* mbedtls_ssl_get_peer_cert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the peer certificate from the current connection. </p>
<pre class="fragment">            Note: Can be NULL in case no certificate was sent during
            the handshake. Different calls for the same connection can
            return the same or different pointers for the same
            certificate and even a different certificate altogether.
            The peer cert CAN change in a single connection if
            renegotiation is performed.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>SSL context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the current peer certificate </dd></dl>

</div>
</div>
<a id="ac583292bcb5db73c00b7350a7c2a79a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac583292bcb5db73c00b7350a7c2a79a2">&#9670;&nbsp;</a></span>mbedtls_ssl_get_session()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_get_session </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../da/def/structmbedtls__ssl__session.html">mbedtls_ssl_session</a> *&#160;</td>
          <td class="paramname"><em>session</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save session in order to resume it later (client-side only) Session data is copied to presented session structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>SSL context </td></tr>
    <tr><td class="paramname">session</td><td>session context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, MBEDTLS_ERR_SSL_ALLOC_FAILED if memory allocation failed, MBEDTLS_ERR_SSL_BAD_INPUT_DATA if used server-side or arguments are otherwise invalid.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only the server certificate is copied, and not the full chain, so you should not attempt to validate the certificate again by calling <code><a class="el" href="../../da/dc4/group__x509__module.html#ga98ed4504e4f832b735a230acf54fcde3" title="Verify the certificate signature.">mbedtls_x509_crt_verify()</a></code> on it. Instead, you should use the results from the verification in the original handshake by calling <code><a class="el" href="../../df/d6d/ssl_8h.html#a516064f1468d459159ef7cd6c496a026" title="Return the result of the certificate verification.">mbedtls_ssl_get_verify_result()</a></code> after loading the session again into a new SSL context using <code><a class="el" href="../../df/d6d/ssl_8h.html#a91be5c606b9f7c1e44b3e507a4fe7b66" title="Request resumption of session (client-side only) Session data is copied from presented session struct...">mbedtls_ssl_set_session()</a></code>.</dd>
<dd>
Once the session object is not needed anymore, you should free it by calling <code><a class="el" href="../../df/d6d/ssl_8h.html#ac085defe1a02ab784a0a2fb201bcc741" title="Free referenced items in an SSL session including the peer certificate and clear memory.">mbedtls_ssl_session_free()</a></code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../df/d6d/ssl_8h.html#a91be5c606b9f7c1e44b3e507a4fe7b66" title="Request resumption of session (client-side only) Session data is copied from presented session struct...">mbedtls_ssl_set_session()</a> </dd></dl>

</div>
</div>
<a id="aac1583fe56eda081580742999968bbcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac1583fe56eda081580742999968bbcf">&#9670;&nbsp;</a></span>mbedtls_ssl_handshake_step()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_handshake_step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a single step of the SSL handshake. </p>
<dl class="section note"><dt>Note</dt><dd>The state of the context (ssl-&gt;state) will be at the next state after this function returns <code>0</code>. Do not call this function if state is MBEDTLS_SSL_HANDSHAKE_OVER.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>SSL context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="../../df/d6d/ssl_8h.html#a4a37e497cd08c896870a42b1b618186e" title="Perform the SSL handshake.">mbedtls_ssl_handshake()</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If this function returns something other than <code>0</code>, #MBEDTLS_ERR_SSL_WANT_READ, #MBEDTLS_ERR_SSL_WANT_WRITE, #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS or #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS, you must stop using the SSL context for reading or writing, and either free it or call <code><a class="el" href="../../df/d6d/ssl_8h.html#a21432367cbce428f10dcb62d9456fa7e" title="Reset an already initialized SSL context for re-use while retaining application-set variables,...">mbedtls_ssl_session_reset()</a></code> on it before re-using it for a new connection; the current connection must be closed. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/df9/ssl__tls_8c_aac1583fe56eda081580742999968bbcf_cgraph.png" border="0" usemap="#ad4/df9/ssl__tls_8c_aac1583fe56eda081580742999968bbcf_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a4a37e497cd08c896870a42b1b618186e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a37e497cd08c896870a42b1b618186e">&#9670;&nbsp;</a></span>mbedtls_ssl_handshake()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_handshake </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform the SSL handshake. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>SSL context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0</code> if successful. </dd>
<dd>
#MBEDTLS_ERR_SSL_WANT_READ or #MBEDTLS_ERR_SSL_WANT_WRITE if the handshake is incomplete and waiting for data to be available for reading from or writing to the underlying transport - in this case you must call this function again when the underlying transport is ready for the operation. </dd>
<dd>
#MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS if an asynchronous operation is in progress (see <a class="el" href="../../df/d6d/ssl_8h.html#a0675aed5a2b2b9ff219a62ed28b50819" title="Configure asynchronous private key operation callbacks.">mbedtls_ssl_conf_async_private_cb()</a>) - in this case you must call this function again when the operation is ready. </dd>
<dd>
#MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS if a cryptographic operation is in progress (see <a class="el" href="../../d4/d4d/ecp_8c.html#a4116275f34714de2218e8969611b6f42" title="Set the maximum number of basic operations done in a row.">mbedtls_ecp_set_max_ops()</a>) - in this case you must call this function again to complete the handshake when you're done attending other tasks. </dd>
<dd>
#MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED if DTLS is in use and the client did not demonstrate reachability yet - in this case you must stop using the context (see below). </dd>
<dd>
Another SSL error code - in this case you must stop using the context (see below).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If this function returns something other than <code>0</code>, #MBEDTLS_ERR_SSL_WANT_READ, #MBEDTLS_ERR_SSL_WANT_WRITE, #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS or #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS, you must stop using the SSL context for reading or writing, and either free it or call <code><a class="el" href="../../df/d6d/ssl_8h.html#a21432367cbce428f10dcb62d9456fa7e" title="Reset an already initialized SSL context for re-use while retaining application-set variables,...">mbedtls_ssl_session_reset()</a></code> on it before re-using it for a new connection; the current connection must be closed.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If DTLS is in use, then you may choose to handle #MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED specially for logging purposes, as it is an expected return value rather than an actual error, but you still need to reset/free the context.</dd>
<dd>
Remarks regarding event-driven DTLS: If the function returns #MBEDTLS_ERR_SSL_WANT_READ, no datagram from the underlying transport layer is currently being processed, and it is safe to idle until the timer or the underlying transport signal a new event. This is not true for a successful handshake, in which case the datagram of the underlying transport that is currently being processed might or might not contain further DTLS records. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/df9/ssl__tls_8c_a4a37e497cd08c896870a42b1b618186e_cgraph.png" border="0" usemap="#ad4/df9/ssl__tls_8c_a4a37e497cd08c896870a42b1b618186e_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a49b7a27a616495d5f0a4fabc3f550dbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49b7a27a616495d5f0a4fabc3f550dbb">&#9670;&nbsp;</a></span>mbedtls_ssl_renegotiate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_renegotiate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiate an SSL renegotiation on the running connection. Client: perform the renegotiation right now. Server: request renegotiation, which will be performed during the next call to <a class="el" href="../../df/d6d/ssl_8h.html#aa2c29eeb1deaf5ad9f01a7515006ede5" title="Read at most &#39;len&#39; application data bytes.">mbedtls_ssl_read()</a> if honored by client. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>SSL context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or any <a class="el" href="../../df/d6d/ssl_8h.html#a4a37e497cd08c896870a42b1b618186e" title="Perform the SSL handshake.">mbedtls_ssl_handshake()</a> return value except #MBEDTLS_ERR_SSL_CLIENT_RECONNECT that can't happen during a renegotiation.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If this function returns something other than <code>0</code>, #MBEDTLS_ERR_SSL_WANT_READ, #MBEDTLS_ERR_SSL_WANT_WRITE, #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS or #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS, you must stop using the SSL context for reading or writing, and either free it or call <code><a class="el" href="../../df/d6d/ssl_8h.html#a21432367cbce428f10dcb62d9456fa7e" title="Reset an already initialized SSL context for re-use while retaining application-set variables,...">mbedtls_ssl_session_reset()</a></code> on it before re-using it for a new connection; the current connection must be closed. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/df9/ssl__tls_8c_a49b7a27a616495d5f0a4fabc3f550dbb_cgraph.png" border="0" usemap="#ad4/df9/ssl__tls_8c_a49b7a27a616495d5f0a4fabc3f550dbb_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="aa2c29eeb1deaf5ad9f01a7515006ede5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2c29eeb1deaf5ad9f01a7515006ede5">&#9670;&nbsp;</a></span>mbedtls_ssl_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read at most 'len' application data bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>SSL context </td></tr>
    <tr><td class="paramname">buf</td><td>buffer that will hold the data </td></tr>
    <tr><td class="paramname">len</td><td>maximum number of bytes to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The (positive) number of bytes read if successful. </dd>
<dd>
<code>0</code> if the read end of the underlying transport was closed<ul>
<li>in this case you must stop using the context (see below). </li>
</ul>
</dd>
<dd>
#MBEDTLS_ERR_SSL_WANT_READ or #MBEDTLS_ERR_SSL_WANT_WRITE if the handshake is incomplete and waiting for data to be available for reading from or writing to the underlying transport - in this case you must call this function again when the underlying transport is ready for the operation. </dd>
<dd>
#MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS if an asynchronous operation is in progress (see <a class="el" href="../../df/d6d/ssl_8h.html#a0675aed5a2b2b9ff219a62ed28b50819" title="Configure asynchronous private key operation callbacks.">mbedtls_ssl_conf_async_private_cb()</a>) - in this case you must call this function again when the operation is ready. </dd>
<dd>
#MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS if a cryptographic operation is in progress (see <a class="el" href="../../d4/d4d/ecp_8c.html#a4116275f34714de2218e8969611b6f42" title="Set the maximum number of basic operations done in a row.">mbedtls_ecp_set_max_ops()</a>) - in this case you must call this function again to complete the handshake when you're done attending other tasks. </dd>
<dd>
#MBEDTLS_ERR_SSL_CLIENT_RECONNECT if we're at the server side of a DTLS connection and the client is initiating a new connection using the same source port. See below. </dd>
<dd>
Another SSL error code - in this case you must stop using the context (see below).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If this function returns something other than a positive value, #MBEDTLS_ERR_SSL_WANT_READ, #MBEDTLS_ERR_SSL_WANT_WRITE, #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS, #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS or #MBEDTLS_ERR_SSL_CLIENT_RECONNECT, you must stop using the SSL context for reading or writing, and either free it or call <code><a class="el" href="../../df/d6d/ssl_8h.html#a21432367cbce428f10dcb62d9456fa7e" title="Reset an already initialized SSL context for re-use while retaining application-set variables,...">mbedtls_ssl_session_reset()</a></code> on it before re-using it for a new connection; the current connection must be closed.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>When this function returns #MBEDTLS_ERR_SSL_CLIENT_RECONNECT (which can only happen server-side), it means that a client is initiating a new connection using the same source port. You can either treat that as a connection close and wait for the client to resend a ClientHello, or directly continue with <code><a class="el" href="../../df/d6d/ssl_8h.html#a4a37e497cd08c896870a42b1b618186e" title="Perform the SSL handshake.">mbedtls_ssl_handshake()</a></code> with the same context (as it has been reset internally). Either way, you must make sure this is seen by the application as a new connection: application state, if any, should be reset, and most importantly the identity of the client must be checked again. WARNING: not validating the identity of the client again, or not transmitting the new identity to the application layer, would allow authentication bypass!</dd>
<dd>
Remarks regarding event-driven DTLS:<ul>
<li>If the function returns #MBEDTLS_ERR_SSL_WANT_READ, no datagram from the underlying transport layer is currently being processed, and it is safe to idle until the timer or the underlying transport signal a new event.</li>
<li>This function may return MBEDTLS_ERR_SSL_WANT_READ even if data was initially available on the underlying transport, as this data may have been only e.g. duplicated messages or a renegotiation request. Therefore, you must be prepared to receive MBEDTLS_ERR_SSL_WANT_READ even when reacting to an incoming-data event from the underlying transport.</li>
<li>On success, the datagram of the underlying transport that is currently being processed may contain further DTLS records. You should call <code>mbedtls_ssl_check_pending</code> to check for remaining records. </li>
</ul>
</dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/df9/ssl__tls_8c_aa2c29eeb1deaf5ad9f01a7515006ede5_cgraph.png" border="0" usemap="#ad4/df9/ssl__tls_8c_aa2c29eeb1deaf5ad9f01a7515006ede5_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a5bbda87d484de82df730758b475f32e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bbda87d484de82df730758b475f32e5">&#9670;&nbsp;</a></span>mbedtls_ssl_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to write exactly 'len' application data bytes. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function will do partial writes in some cases. If the return value is non-negative but less than length, the function must be called again with updated arguments: buf + ret, len - ret (if ret is the return value) until it returns a value equal to the last 'len' argument.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>SSL context </td></tr>
    <tr><td class="paramname">buf</td><td>buffer holding the data </td></tr>
    <tr><td class="paramname">len</td><td>how many bytes must be written</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The (non-negative) number of bytes actually written if successful (may be less than <code>len</code>). </dd>
<dd>
#MBEDTLS_ERR_SSL_WANT_READ or #MBEDTLS_ERR_SSL_WANT_WRITE if the handshake is incomplete and waiting for data to be available for reading from or writing to the underlying transport - in this case you must call this function again when the underlying transport is ready for the operation. </dd>
<dd>
#MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS if an asynchronous operation is in progress (see <a class="el" href="../../df/d6d/ssl_8h.html#a0675aed5a2b2b9ff219a62ed28b50819" title="Configure asynchronous private key operation callbacks.">mbedtls_ssl_conf_async_private_cb()</a>) - in this case you must call this function again when the operation is ready. </dd>
<dd>
#MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS if a cryptographic operation is in progress (see <a class="el" href="../../d4/d4d/ecp_8c.html#a4116275f34714de2218e8969611b6f42" title="Set the maximum number of basic operations done in a row.">mbedtls_ecp_set_max_ops()</a>) - in this case you must call this function again to complete the handshake when you're done attending other tasks. </dd>
<dd>
Another SSL error code - in this case you must stop using the context (see below).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If this function returns something other than a non-negative value, #MBEDTLS_ERR_SSL_WANT_READ, #MBEDTLS_ERR_SSL_WANT_WRITE, #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS or #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS, you must stop using the SSL context for reading or writing, and either free it or call <code><a class="el" href="../../df/d6d/ssl_8h.html#a21432367cbce428f10dcb62d9456fa7e" title="Reset an already initialized SSL context for re-use while retaining application-set variables,...">mbedtls_ssl_session_reset()</a></code> on it before re-using it for a new connection; the current connection must be closed.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>When this function returns #MBEDTLS_ERR_SSL_WANT_WRITE/READ, it must be called later with the <em>same</em> arguments, until it returns a value greater that or equal to 0. When the function returns #MBEDTLS_ERR_SSL_WANT_WRITE there may be some partial data in the output buffer, however this is not yet sent.</dd>
<dd>
If the requested length is greater than the maximum fragment length (either the built-in limit or the one set or negotiated with the peer), then:<ul>
<li>with TLS, less bytes than requested are written.</li>
<li>with DTLS, MBEDTLS_ERR_SSL_BAD_INPUT_DATA is returned. <code><a class="el" href="../../df/d6d/ssl_8h.html#a44fb4dcf45412d667778432836be9150" title="Return the maximum fragment length (payload, in bytes). This is the value negotiated with peer if any...">mbedtls_ssl_get_max_frag_len()</a></code> may be used to query the active maximum fragment length.</li>
</ul>
</dd>
<dd>
Attempting to write 0 bytes will result in an empty TLS application record being sent. </dd></dl>

</div>
</div>
<a id="ac2c1b17128ead2df3082e27b603deb4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2c1b17128ead2df3082e27b603deb4c">&#9670;&nbsp;</a></span>mbedtls_ssl_close_notify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_close_notify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notify the peer that the connection is being closed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>SSL context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or a specific SSL error code.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If this function returns something other than 0 or MBEDTLS_ERR_SSL_WANT_READ/WRITE, you must stop using the SSL context for reading or writing, and either free it or call <code><a class="el" href="../../df/d6d/ssl_8h.html#a21432367cbce428f10dcb62d9456fa7e" title="Reset an already initialized SSL context for re-use while retaining application-set variables,...">mbedtls_ssl_session_reset()</a></code> on it before re-using it for a new connection; the current connection must be closed. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/df9/ssl__tls_8c_ac2c1b17128ead2df3082e27b603deb4c_cgraph.png" border="0" usemap="#ad4/df9/ssl__tls_8c_ac2c1b17128ead2df3082e27b603deb4c_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a2d2364679f41031b1c26ef50731e76fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d2364679f41031b1c26ef50731e76fb">&#9670;&nbsp;</a></span>mbedtls_ssl_transform_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_transform_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/d5d/structmbedtls__ssl__transform.html">mbedtls_ssl_transform</a> *&#160;</td>
          <td class="paramname"><em>transform</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free referenced items in an SSL transform context and clear memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td>SSL transform context </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/df9/ssl__tls_8c_a2d2364679f41031b1c26ef50731e76fb_cgraph.png" border="0" usemap="#ad4/df9/ssl__tls_8c_a2d2364679f41031b1c26ef50731e76fb_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a15fc29ce95f7f0f0f5f9571ddb38ea9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15fc29ce95f7f0f0f5f9571ddb38ea9e">&#9670;&nbsp;</a></span>mbedtls_ssl_handshake_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_handshake_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free referenced items in an SSL handshake context and clear memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>SSL context </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/df9/ssl__tls_8c_a15fc29ce95f7f0f0f5f9571ddb38ea9e_cgraph.png" border="0" usemap="#ad4/df9/ssl__tls_8c_a15fc29ce95f7f0f0f5f9571ddb38ea9e_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="ac085defe1a02ab784a0a2fb201bcc741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac085defe1a02ab784a0a2fb201bcc741">&#9670;&nbsp;</a></span>mbedtls_ssl_session_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_session_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/def/structmbedtls__ssl__session.html">mbedtls_ssl_session</a> *&#160;</td>
          <td class="paramname"><em>session</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free referenced items in an SSL session including the peer certificate and clear memory. </p>
<dl class="section note"><dt>Note</dt><dd>A session object can be freed even if the SSL context that was used to retrieve the session is still in use.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>SSL session </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/df9/ssl__tls_8c_ac085defe1a02ab784a0a2fb201bcc741_cgraph.png" border="0" usemap="#ad4/df9/ssl__tls_8c_ac085defe1a02ab784a0a2fb201bcc741_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a2dc104a181bcd11eafbbf7e6923978bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dc104a181bcd11eafbbf7e6923978bc">&#9670;&nbsp;</a></span>mbedtls_ssl_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free referenced items in an SSL context and clear memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssl</td><td>SSL context </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/df9/ssl__tls_8c_a2dc104a181bcd11eafbbf7e6923978bc_cgraph.png" border="0" usemap="#ad4/df9/ssl__tls_8c_a2dc104a181bcd11eafbbf7e6923978bc_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="aba55bcda50a47e83803e31a8db7c9a86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba55bcda50a47e83803e31a8db7c9a86">&#9670;&nbsp;</a></span>mbedtls_ssl_config_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_config_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize an SSL configuration context Just makes the context ready for <a class="el" href="../../df/d6d/ssl_8h.html#aa1335b65ba57e81accc91ef95454d5a6" title="Load reasonnable default SSL configuration values. (You need to call mbedtls_ssl_config_init() first....">mbedtls_ssl_config_defaults()</a> or <a class="el" href="../../df/d6d/ssl_8h.html#a7655f025440a6c5ccd4fc13832abb1dd" title="Free an SSL configuration context.">mbedtls_ssl_config_free()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>You need to call <a class="el" href="../../df/d6d/ssl_8h.html#aa1335b65ba57e81accc91ef95454d5a6" title="Load reasonnable default SSL configuration values. (You need to call mbedtls_ssl_config_init() first....">mbedtls_ssl_config_defaults()</a> unless you manually set all of the relevent fields yourself.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1335b65ba57e81accc91ef95454d5a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1335b65ba57e81accc91ef95454d5a6">&#9670;&nbsp;</a></span>mbedtls_ssl_config_defaults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_config_defaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>transport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>preset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load reasonnable default SSL configuration values. (You need to call <a class="el" href="../../df/d6d/ssl_8h.html#aba55bcda50a47e83803e31a8db7c9a86" title="Initialize an SSL configuration context Just makes the context ready for mbedtls_ssl_config_defaults(...">mbedtls_ssl_config_init()</a> first.) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration context </td></tr>
    <tr><td class="paramname">endpoint</td><td>MBEDTLS_SSL_IS_CLIENT or MBEDTLS_SSL_IS_SERVER </td></tr>
    <tr><td class="paramname">transport</td><td>MBEDTLS_SSL_TRANSPORT_STREAM for TLS, or MBEDTLS_SSL_TRANSPORT_DATAGRAM for DTLS </td></tr>
    <tr><td class="paramname">preset</td><td>a MBEDTLS_SSL_PRESET_XXX value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>See <code><a class="el" href="../../df/d6d/ssl_8h.html#a2eb03afe9b2ca0f144a1c307100dc0ca" title="Set the transport type (TLS or DTLS). Default: TLS.">mbedtls_ssl_conf_transport()</a></code> for notes on DTLS.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or MBEDTLS_ERR_XXX_ALLOC_FAILED on memory allocation error. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/df9/ssl__tls_8c_aa1335b65ba57e81accc91ef95454d5a6_cgraph.png" border="0" usemap="#ad4/df9/ssl__tls_8c_aa1335b65ba57e81accc91ef95454d5a6_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a7655f025440a6c5ccd4fc13832abb1dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7655f025440a6c5ccd4fc13832abb1dd">&#9670;&nbsp;</a></span>mbedtls_ssl_config_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_config_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d69/structmbedtls__ssl__config.html">mbedtls_ssl_config</a> *&#160;</td>
          <td class="paramname"><em>conf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free an SSL configuration context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>SSL configuration context </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/df9/ssl__tls_8c_a7655f025440a6c5ccd4fc13832abb1dd_cgraph.png" border="0" usemap="#ad4/df9/ssl__tls_8c_a7655f025440a6c5ccd4fc13832abb1dd_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="af084cb7351cb61bf6e97acd2bb4f9cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af084cb7351cb61bf6e97acd2bb4f9cd2">&#9670;&nbsp;</a></span>mbedtls_ssl_sig_from_pk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char mbedtls_ssl_sig_from_pk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d1b/structmbedtls__pk__context.html">mbedtls_pk_context</a> *&#160;</td>
          <td class="paramname"><em>pk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/df9/ssl__tls_8c_af084cb7351cb61bf6e97acd2bb4f9cd2_cgraph.png" border="0" usemap="#ad4/df9/ssl__tls_8c_af084cb7351cb61bf6e97acd2bb4f9cd2_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a315536e7dc02769c9ee562f68d6ebd70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a315536e7dc02769c9ee562f68d6ebd70">&#9670;&nbsp;</a></span>mbedtls_ssl_sig_from_pk_alg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char mbedtls_ssl_sig_from_pk_alg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/dd6/pk_8h.html#a3fe41eff5605ae727eb9d28dad297020">mbedtls_pk_type_t</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a06fac477160b85cb5b4dc325de933a30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06fac477160b85cb5b4dc325de933a30">&#9670;&nbsp;</a></span>mbedtls_ssl_pk_alg_from_sig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dd6/pk_8h.html#a3fe41eff5605ae727eb9d28dad297020">mbedtls_pk_type_t</a> mbedtls_ssl_pk_alg_from_sig </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a40fe4e983b1baa16ddd3b45894c0c932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40fe4e983b1baa16ddd3b45894c0c932">&#9670;&nbsp;</a></span>mbedtls_ssl_sig_hash_set_find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dbf/md_8h.html#a219313cb40503ec3e34a857ab98b2296">mbedtls_md_type_t</a> mbedtls_ssl_sig_hash_set_find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d21/structmbedtls__ssl__sig__hash__set__t.html">mbedtls_ssl_sig_hash_set_t</a> *&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/dd6/pk_8h.html#a3fe41eff5605ae727eb9d28dad297020">mbedtls_pk_type_t</a>&#160;</td>
          <td class="paramname"><em>sig_alg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abaa145b4b8342e17bd7e2457a4e73c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa145b4b8342e17bd7e2457a4e73c51">&#9670;&nbsp;</a></span>mbedtls_ssl_sig_hash_set_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_sig_hash_set_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d21/structmbedtls__ssl__sig__hash__set__t.html">mbedtls_ssl_sig_hash_set_t</a> *&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/dd6/pk_8h.html#a3fe41eff5605ae727eb9d28dad297020">mbedtls_pk_type_t</a>&#160;</td>
          <td class="paramname"><em>sig_alg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/dbf/md_8h.html#a219313cb40503ec3e34a857ab98b2296">mbedtls_md_type_t</a>&#160;</td>
          <td class="paramname"><em>md_alg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a067168987e892b97cef9e31599cadc3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a067168987e892b97cef9e31599cadc3f">&#9670;&nbsp;</a></span>mbedtls_ssl_sig_hash_set_const_hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_sig_hash_set_const_hash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d21/structmbedtls__ssl__sig__hash__set__t.html">mbedtls_ssl_sig_hash_set_t</a> *&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/dbf/md_8h.html#a219313cb40503ec3e34a857ab98b2296">mbedtls_md_type_t</a>&#160;</td>
          <td class="paramname"><em>md_alg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a38919961fbabe3adb94c5798d1dc9610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38919961fbabe3adb94c5798d1dc9610">&#9670;&nbsp;</a></span>mbedtls_ssl_md_alg_from_hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/dbf/md_8h.html#a219313cb40503ec3e34a857ab98b2296">mbedtls_md_type_t</a> mbedtls_ssl_md_alg_from_hash </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac895f60c4cd63713bdfa3336084f1e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac895f60c4cd63713bdfa3336084f1e5b">&#9670;&nbsp;</a></span>mbedtls_ssl_hash_from_md_alg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char mbedtls_ssl_hash_from_md_alg </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>md</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae7bfd81f7c8c03c875d8028169e2407e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7bfd81f7c8c03c875d8028169e2407e">&#9670;&nbsp;</a></span>mbedtls_ssl_check_curve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_check_curve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/df7/ecp_8h.html#af79e530ea8f8416480f805baa20b1a2d">mbedtls_ecp_group_id</a>&#160;</td>
          <td class="paramname"><em>grp_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a84159147b73016145706a3dc247621c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84159147b73016145706a3dc247621c1">&#9670;&nbsp;</a></span>mbedtls_ssl_check_sig_hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_check_sig_hash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/dbf/md_8h.html#a219313cb40503ec3e34a857ab98b2296">mbedtls_md_type_t</a>&#160;</td>
          <td class="paramname"><em>md</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5dd3c0caa2ad38ece4a1a0ad08ccd059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dd3c0caa2ad38ece4a1a0ad08ccd059">&#9670;&nbsp;</a></span>mbedtls_ssl_check_cert_usage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_check_cert_usage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/daa/structmbedtls__x509__crt.html">mbedtls_x509_crt</a> *&#160;</td>
          <td class="paramname"><em>cert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d7a/structmbedtls__ssl__ciphersuite__t.html">mbedtls_ssl_ciphersuite_t</a> *&#160;</td>
          <td class="paramname"><em>ciphersuite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cert_endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/df9/ssl__tls_8c_a5dd3c0caa2ad38ece4a1a0ad08ccd059_cgraph.png" border="0" usemap="#ad4/df9/ssl__tls_8c_a5dd3c0caa2ad38ece4a1a0ad08ccd059_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a4f7438e9eb43bbfc167ff48ccfaab033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f7438e9eb43bbfc167ff48ccfaab033">&#9670;&nbsp;</a></span>mbedtls_ssl_write_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_write_version </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>major</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>transport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>ver</em>[2]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b290906063a6e619cee055f881580fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b290906063a6e619cee055f881580fe">&#9670;&nbsp;</a></span>mbedtls_ssl_read_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbedtls_ssl_read_version </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>major</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>minor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>transport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>ver</em>[2]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac932e0439258a97117482fe38e59eaff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac932e0439258a97117482fe38e59eaff">&#9670;&nbsp;</a></span>mbedtls_ssl_set_calc_verify_md()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_set_calc_verify_md </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>md</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/df9/ssl__tls_8c_ac932e0439258a97117482fe38e59eaff_cgraph.png" border="0" usemap="#ad4/df9/ssl__tls_8c_ac932e0439258a97117482fe38e59eaff_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="ad56448eab60a42579427eed05bfa69d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad56448eab60a42579427eed05bfa69d1">&#9670;&nbsp;</a></span>mbedtls_ssl_get_key_exchange_md_ssl_tls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_get_key_exchange_md_ssl_tls </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/df9/ssl__tls_8c_ad56448eab60a42579427eed05bfa69d1_cgraph.png" border="0" usemap="#ad4/df9/ssl__tls_8c_ad56448eab60a42579427eed05bfa69d1_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="ad3aa894a685365d2234a3571dc2ba14b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3aa894a685365d2234a3571dc2ba14b">&#9670;&nbsp;</a></span>mbedtls_ssl_get_key_exchange_md_tls1_2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbedtls_ssl_get_key_exchange_md_tls1_2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *&#160;</td>
          <td class="paramname"><em>ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>hashlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/dbf/md_8h.html#a219313cb40503ec3e34a857ab98b2296">mbedtls_md_type_t</a>&#160;</td>
          <td class="paramname"><em>md_alg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/df9/ssl__tls_8c_ad3aa894a685365d2234a3571dc2ba14b_cgraph.png" border="0" usemap="#ad4/df9/ssl__tls_8c_ad3aa894a685365d2234a3571dc2ba14b_cgraph" alt=""/></div>
</div>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a5b2092401b8076dabc962911b0758cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b2092401b8076dabc962911b0758cff">&#9670;&nbsp;</a></span>mbedtls_ssl_hw_record_init</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* mbedtls_ssl_hw_record_init) (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl, const unsigned char *key_enc, const unsigned char *key_dec, size_t keylen, const unsigned char *iv_enc, const unsigned char *iv_dec, size_t ivlen, const unsigned char *mac_enc, const unsigned char *mac_dec, size_t maclen) = NULL</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac364a9fc4d0342743cbe0a0a5c242f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac364a9fc4d0342743cbe0a0a5c242f2c">&#9670;&nbsp;</a></span>mbedtls_ssl_hw_record_activate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* mbedtls_ssl_hw_record_activate) (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl, int direction) = NULL</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7e3fc02bc07e01521db4fc3019e47e5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e3fc02bc07e01521db4fc3019e47e5c">&#9670;&nbsp;</a></span>mbedtls_ssl_hw_record_reset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* mbedtls_ssl_hw_record_reset) (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl) = NULL</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae65226ba7a00590e47b0fe8b295df8d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae65226ba7a00590e47b0fe8b295df8d1">&#9670;&nbsp;</a></span>mbedtls_ssl_hw_record_write</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* mbedtls_ssl_hw_record_write) (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl) = NULL</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b997dbd2572e5217b3e438f8576e6f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b997dbd2572e5217b3e438f8576e6f4">&#9670;&nbsp;</a></span>mbedtls_ssl_hw_record_read</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* mbedtls_ssl_hw_record_read) (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl) = NULL</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac535a2f5139611bc45242460f48bfcdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac535a2f5139611bc45242460f48bfcdf">&#9670;&nbsp;</a></span>mbedtls_ssl_hw_record_finish</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* mbedtls_ssl_hw_record_finish) (<a class="el" href="../../d9/df5/structmbedtls__ssl__context.html">mbedtls_ssl_context</a> *ssl) = NULL</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="../../dir_7f7598ebb7008b1972f2cc3333f8faed.html">mbedtls</a></li><li class="navelem"><a class="el" href="../../d4/df9/ssl__tls_8c.html">ssl_tls.c</a></li>
    <li class="footer">Generated by <a href="http://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
